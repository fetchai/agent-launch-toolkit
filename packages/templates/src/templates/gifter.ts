/**
 * gifter.ts — FET Gifter pattern: distributes testnet FET and BNB to new developers
 *
 * This template is based on the FET Gifter agent pattern (faucet type from
 * packages/cli/src/commands/scaffold.ts). It adapts the gifter use case for
 * Agentverse-native deployment with Chat Protocol v0.3.0.
 *
 * Platform constants (source of truth: deployed smart contracts):
 *   - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
 *   - Graduation target: 30,000 FET -> auto DEX listing
 *   - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)
 */

import type { AgentTemplate } from "../registry.js";

// Environment-based URL resolution (production is default, set AGENT_LAUNCH_ENV=dev for dev)
const PROD_API_URL = 'https://agent-launch.ai/api';
const DEV_API_URL = 'https://launchpad-backend-dev-1056182620041.us-central1.run.app';
const RESOLVED_API_URL = process.env.AGENT_LAUNCH_API_URL ??
  (process.env.AGENT_LAUNCH_ENV === 'dev' ? DEV_API_URL : PROD_API_URL);

export const template: AgentTemplate = {
  name: "gifter",
  description:
    "Distributes testnet FET and BNB to new developers — the FET Gifter pattern",
  category: "Infrastructure",
  variables: [
    { name: "agent_name", required: true, description: "Name of the agent" },
    {
      name: "description",
      default: "Distributes testnet FET and BNB to new developers",
      description: "Short description of what this agent does",
    },
    {
      name: "daily_gift_limit_fet",
      default: "100",
      description: "Maximum FET to gift per user per day",
    },
    {
      name: "daily_gift_limit_bnb",
      default: "0.01",
      description: "Maximum BNB to gift per user per day",
    },
    {
      name: "treasury_address",
      required: true,
      description: "Wallet address that holds the gift funds",
    },
    {
      name: "rate_limit_per_minute",
      default: "5",
      description: "Max gift requests per user per minute",
    },
    {
      name: "free_requests_per_day",
      default: "3",
      description: "Free gift requests allowed per user per day",
    },
    {
      name: "premium_token_threshold",
      default: "1000",
      description: "Token balance required for premium tier (higher gift limit)",
    },
  ],
  dependencies: ["requests", "web3"],
  secrets: [
    "AGENTVERSE_API_KEY",
    "AGENTLAUNCH_API_KEY",
    "AGENT_ADDRESS",
    "AGENT_OWNER_ADDRESS",
    "TREASURY_PRIVATE_KEY",
    "BSC_TESTNET_RPC",
    "ETH_SEPOLIA_RPC",
  ],
  code: `#!/usr/bin/env python3
"""
{{agent_name}} — AgentLaunch FET Gifter Agent
Generated by: agentlaunch scaffold {{agent_name}} --type gifter

Distributes testnet FET (BSC Testnet) and BNB to new developers so they can
explore the AgentLaunch platform without needing to acquire testnet funds.

Pattern: FET Gifter — Agent + Wallet + Chat + Value Exchange = Ecosystem onboarding

Platform constants (source of truth: deployed smart contracts):
  - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
  - Graduation target: 30,000 FET -> auto DEX listing
  - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)

SECURITY NOTES:
  - TREASURY_PRIVATE_KEY must be set as an Agentverse secret, never hardcoded
  - Treasury wallet should hold ONLY testnet funds
  - All gift recipients are logged for audit
  - Daily limits enforced per recipient address
"""

from uagents import Agent, Context, Protocol
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    EndSessionContent,
    TextContent,
    chat_protocol_spec,
)

import json
import os
import time
from collections import defaultdict
from datetime import datetime, date
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

import requests

# ==============================================================================
# API CONFIG — Override via environment variables, never hardcode
# ==============================================================================

AGENTLAUNCH_API = os.environ.get("AGENTLAUNCH_API", "${RESOLVED_API_URL}")
BSC_TESTNET_RPC = os.environ.get("BSC_TESTNET_RPC", "https://data-seed-prebsc-1-s1.binance.org:8545")
ETH_SEPOLIA_RPC = os.environ.get("ETH_SEPOLIA_RPC", "https://rpc.sepolia.org")

# Testnet FET contract on BSC Testnet
FET_CONTRACT_BSC_TESTNET = "0x210778e62C17b4F7B6De7ab27346e4C35e3b1b5"

# ==============================================================================
# BUSINESS CONFIG
# ==============================================================================

OWNER_ADDRESS = os.environ.get("AGENT_OWNER_ADDRESS", "")
TREASURY_ADDRESS = os.environ.get("TREASURY_ADDRESS", "{{treasury_address}}")

BUSINESS = {
    "name": "{{agent_name}}",
    "description": "{{description}}",
    "version": "1.0.0",
    "daily_gift_limit_fet": float("{{daily_gift_limit_fet}}"),
    "daily_gift_limit_bnb": float("{{daily_gift_limit_bnb}}"),
    "free_requests_per_day": {{free_requests_per_day}},
    "premium_token_threshold": {{premium_token_threshold}},
    "rate_limit_per_minute": {{rate_limit_per_minute}},
    "max_input_length": 5000,
}

# ERC20 minimal ABI for FET transfers
ERC20_ABI = [
    {
        "name": "transfer",
        "type": "function",
        "inputs": [
            {"name": "to", "type": "address"},
            {"name": "value", "type": "uint256"},
        ],
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "nonpayable",
    },
    {
        "name": "balanceOf",
        "type": "function",
        "inputs": [{"name": "account", "type": "address"}],
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view",
    },
    {
        "name": "decimals",
        "type": "function",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint8"}],
        "stateMutability": "view",
    },
]


# ==============================================================================
# LAYER 1: FOUNDATION
# ==============================================================================


class Logger:
    """Structured logging with audit trail."""

    @staticmethod
    def info(ctx: Context, event: str, data: Optional[Dict] = None) -> None:
        ctx.logger.info(f"[{event}] {json.dumps(data or {})}")

    @staticmethod
    def audit(ctx: Context, user: str, action: str) -> None:
        ctx.logger.info(
            f"[AUDIT] user={user[:20]} action={action} "
            f"ts={datetime.utcnow().isoformat()}"
        )

    @staticmethod
    def error(ctx: Context, event: str, error: str) -> None:
        ctx.logger.error(f"[{event}] {error}")


# ==============================================================================
# LAYER 2: SECURITY
# ==============================================================================


class Security:
    """Rate limiting and input validation."""

    def __init__(self) -> None:
        self._requests: Dict[str, List[float]] = defaultdict(list)
        self._check_count: int = 0

    def check(self, ctx: Context, user_id: str, message: str) -> tuple:
        now = time.time()

        self._requests[user_id] = [
            t for t in self._requests[user_id] if now - t < 60
        ]
        if len(self._requests[user_id]) >= BUSINESS["rate_limit_per_minute"]:
            return None, "Rate limit exceeded. Please wait a moment."
        self._requests[user_id].append(now)

        self._check_count += 1
        if self._check_count % 100 == 0:
            stale = [
                k
                for k, v in self._requests.items()
                if not v or (now - max(v)) > 300
            ]
            for k in stale:
                del self._requests[k]

        if not message or not message.strip():
            return None, "Empty message."
        if len(message) > BUSINESS["max_input_length"]:
            return None, f"Message too long (max {BUSINESS['max_input_length']} chars)."

        return message.strip(), None


# ==============================================================================
# LAYER 3: STABILITY
# ==============================================================================


class Health:
    """Track uptime and error rate."""

    def __init__(self) -> None:
        self._start: datetime = datetime.utcnow()
        self._requests: int = 0
        self._errors: int = 0

    def record(self, success: bool) -> None:
        self._requests += 1
        if not success:
            self._errors += 1

    def status(self) -> Dict[str, Any]:
        uptime = (datetime.utcnow() - self._start).total_seconds()
        error_rate = (self._errors / self._requests * 100) if self._requests else 0
        return {
            "status": "healthy" if error_rate < 10 else "degraded",
            "uptime_seconds": int(uptime),
            "requests": self._requests,
            "error_rate": f"{error_rate:.1f}%",
        }


# ==============================================================================
# LAYER 4: SPEED
# ==============================================================================


class Cache:
    """In-memory TTL cache."""

    def __init__(self, max_size: int = 1000) -> None:
        self._data: Dict[str, tuple] = {}
        self._max_size: int = max_size

    def get(self, key: str) -> Any:
        if key in self._data:
            value, expires = self._data[key]
            if expires > time.time():
                return value
            del self._data[key]
        return None

    def set(self, key: str, value: Any, ttl: int = 300) -> None:
        if len(self._data) >= self._max_size:
            now = time.time()
            expired = [k for k, (_, exp) in self._data.items() if exp <= now]
            for k in expired:
                del self._data[k]
            if len(self._data) >= self._max_size:
                to_drop = sorted(self._data.items(), key=lambda x: x[1][1])[
                    : self._max_size // 10
                ]
                for k, _ in to_drop:
                    del self._data[k]
        self._data[key] = (value, time.time() + ttl)


# ==============================================================================
# LAYER 5: REVENUE
# ==============================================================================


class Revenue:
    """Token-gated access and daily usage quotas."""

    def __init__(self, cache: Cache) -> None:
        self._cache = cache
        self._usage: Dict[str, List[str]] = defaultdict(list)

    def get_tier(self, user_address: str) -> str:
        cached = self._cache.get(f"tier:{user_address}")
        if cached is not None:
            return cached
        try:
            r = requests.get(
                f"{AGENTLAUNCH_API}/agents/token/{user_address}", timeout=5
            )
            if r.status_code == 200:
                data = r.json()
                balance = data.get("balance", 0)
                tier = (
                    "premium"
                    if balance >= BUSINESS["premium_token_threshold"]
                    else "free"
                )
                self._cache.set(f"tier:{user_address}", tier, ttl=300)
                return tier
        except Exception:
            pass
        return "free"

    def check_quota(self, user_id: str, tier: str) -> tuple:
        today = datetime.utcnow().date().isoformat()
        self._usage[user_id] = [
            t for t in self._usage[user_id] if t.startswith(today)
        ]
        today_usage = len(self._usage[user_id])
        limit = 1000 if tier == "premium" else BUSINESS["free_requests_per_day"]
        if today_usage >= limit:
            if tier == "free":
                return False, (
                    f"Free limit reached ({limit}/day). "
                    f"Hold {BUSINESS['premium_token_threshold']} tokens for premium!"
                )
            return False, f"Daily limit reached ({limit}/day)."
        self._usage[user_id].append(datetime.utcnow().isoformat())
        return True, None


# ==============================================================================
# AGENTLAUNCH INTEGRATION
# ==============================================================================


class AgentLaunch:
    """Create and manage tokens on AgentLaunch."""

    @staticmethod
    def tokenize() -> Dict:
        agent_address = os.environ.get("AGENT_ADDRESS")
        if not agent_address:
            return {"error": "AGENT_ADDRESS env var not set."}
        try:
            r = requests.post(
                f"{AGENTLAUNCH_API}/agents/tokenize",
                headers={
                    "X-API-Key": os.environ.get("AGENTLAUNCH_API_KEY", ""),
                    "Content-Type": "application/json",
                },
                json={
                    "agentAddress": agent_address,
                    "name": BUSINESS["name"],
                    "description": BUSINESS["description"],
                },
                timeout=30,
            )
            return r.json() if r.status_code in [200, 201] else {"error": r.text}
        except Exception as e:
            return {"error": str(e)}


# ==============================================================================
# GIFTER BUSINESS LOGIC
# ==============================================================================


class GifterBusiness:
    """
    FET Gifter pattern: send testnet FET and BNB to developer wallets.

    Daily limits per recipient:
      - FET: {{daily_gift_limit_fet}} (BSC Testnet)
      - BNB: {{daily_gift_limit_bnb}} (BSC Testnet gas)

    Uses Web3.py for on-chain transfers. Private key loaded from env secret.

    Note: This is for TESTNET only. Treasury holds only testnet funds.
    Note: Trading fee is 2% -> 100% to protocol treasury (no creator fee).
    """

    def __init__(self) -> None:
        self._daily_gifts: Dict[str, Dict[str, float]] = defaultdict(
            lambda: {"fet": 0.0, "bnb": 0.0, "date": date.today().isoformat()}
        )

    def _reset_if_new_day(self, recipient: str) -> None:
        record = self._daily_gifts[recipient]
        if record["date"] != date.today().isoformat():
            self._daily_gifts[recipient] = {"fet": 0.0, "bnb": 0.0, "date": date.today().isoformat()}

    def can_gift_fet(self, recipient: str, amount: float) -> Tuple[bool, str]:
        self._reset_if_new_day(recipient)
        used = self._daily_gifts[recipient]["fet"]
        limit = BUSINESS["daily_gift_limit_fet"]
        if used + amount > limit:
            remaining = max(0.0, limit - used)
            return False, f"Daily FET limit reached. Remaining today: {remaining:.2f} FET"
        return True, ""

    def can_gift_bnb(self, recipient: str, amount: float) -> Tuple[bool, str]:
        self._reset_if_new_day(recipient)
        used = self._daily_gifts[recipient]["bnb"]
        limit = BUSINESS["daily_gift_limit_bnb"]
        if used + amount > limit:
            remaining = max(0.0, limit - used)
            return False, f"Daily BNB limit reached. Remaining today: {remaining:.6f} BNB"
        return True, ""

    def send_fet(self, ctx: Context, recipient: str, amount: float) -> Tuple[bool, str]:
        """Send testnet FET via Web3.py on BSC Testnet."""
        try:
            from web3 import Web3

            private_key = os.environ.get("TREASURY_PRIVATE_KEY", "")
            if not private_key:
                return False, "TREASURY_PRIVATE_KEY not configured."

            w3 = Web3(Web3.HTTPProvider(BSC_TESTNET_RPC))
            if not w3.is_connected():
                return False, "Could not connect to BSC Testnet RPC."

            contract = w3.eth.contract(
                address=Web3.to_checksum_address(FET_CONTRACT_BSC_TESTNET),
                abi=ERC20_ABI,
            )
            decimals = contract.functions.decimals().call()
            amount_wei = int(amount * (10 ** decimals))

            treasury = w3.eth.account.from_key(private_key)
            nonce = w3.eth.get_transaction_count(treasury.address)
            chain_id = w3.eth.chain_id

            tx = contract.functions.transfer(
                Web3.to_checksum_address(recipient), amount_wei
            ).build_transaction({
                "from": treasury.address,
                "nonce": nonce,
                "gas": 100000,
                "gasPrice": w3.eth.gas_price,
                "chainId": chain_id,
            })

            signed = w3.eth.account.sign_transaction(tx, private_key)
            tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)

            self._daily_gifts[recipient]["fet"] += amount
            ctx.logger.info(
                f"[GIFT_FET] recipient={recipient[:20]} amount={amount} "
                f"tx={tx_hash.hex()}"
            )
            return True, f"0x{tx_hash.hex()}"

        except ImportError:
            return False, "web3 package not installed. Run: pip install web3"
        except Exception as e:
            return False, str(e)

    def send_bnb(self, ctx: Context, recipient: str, amount: float) -> Tuple[bool, str]:
        """Send testnet BNB via Web3.py on BSC Testnet."""
        try:
            from web3 import Web3

            private_key = os.environ.get("TREASURY_PRIVATE_KEY", "")
            if not private_key:
                return False, "TREASURY_PRIVATE_KEY not configured."

            w3 = Web3(Web3.HTTPProvider(BSC_TESTNET_RPC))
            if not w3.is_connected():
                return False, "Could not connect to BSC Testnet RPC."

            treasury = w3.eth.account.from_key(private_key)
            nonce = w3.eth.get_transaction_count(treasury.address)
            chain_id = w3.eth.chain_id
            amount_wei = w3.to_wei(amount, "ether")

            tx = {
                "to": Web3.to_checksum_address(recipient),
                "value": amount_wei,
                "gas": 21000,
                "gasPrice": w3.eth.gas_price,
                "nonce": nonce,
                "chainId": chain_id,
            }

            signed = w3.eth.account.sign_transaction(tx, private_key)
            tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)

            self._daily_gifts[recipient]["bnb"] += amount
            ctx.logger.info(
                f"[GIFT_BNB] recipient={recipient[:20]} amount={amount} "
                f"tx={tx_hash.hex()}"
            )
            return True, f"0x{tx_hash.hex()}"

        except ImportError:
            return False, "web3 package not installed. Run: pip install web3"
        except Exception as e:
            return False, str(e)

    async def handle(self, ctx: Context, user_id: str, message: str, tier: str) -> str:
        lower = message.lower()

        # "gift fet <address> [amount]"
        if lower.startswith("gift fet ") or lower.startswith("send fet "):
            parts = message.split()
            if len(parts) < 3:
                return "Usage: gift fet <wallet_address> [amount]"
            recipient = parts[2].strip()
            amount = float(parts[3]) if len(parts) >= 4 else min(10.0, BUSINESS["daily_gift_limit_fet"])

            ok, reason = self.can_gift_fet(recipient, amount)
            if not ok:
                return reason

            Logger.audit(ctx, user_id, f"gift_fet:{recipient[:20]}:{amount}")
            success, result = self.send_fet(ctx, recipient, amount)
            if success:
                return (
                    f"Sent {amount} FET to {recipient[:12]}...\\n"
                    f"Tx: {result}\\n"
                    f"BSC Testnet explorer: https://testnet.bscscan.com/tx/{result}"
                )
            return f"Gift failed: {result}"

        # "gift bnb <address> [amount]"
        if lower.startswith("gift bnb ") or lower.startswith("send bnb "):
            parts = message.split()
            if len(parts) < 3:
                return "Usage: gift bnb <wallet_address> [amount]"
            recipient = parts[2].strip()
            amount = float(parts[3]) if len(parts) >= 4 else BUSINESS["daily_gift_limit_bnb"]

            ok, reason = self.can_gift_bnb(recipient, amount)
            if not ok:
                return reason

            Logger.audit(ctx, user_id, f"gift_bnb:{recipient[:20]}:{amount}")
            success, result = self.send_bnb(ctx, recipient, amount)
            if success:
                return (
                    f"Sent {amount} BNB to {recipient[:12]}...\\n"
                    f"Tx: {result}\\n"
                    f"BSC Testnet explorer: https://testnet.bscscan.com/tx/{result}"
                )
            return f"Gift failed: {result}"

        # "limits" — show current daily allowances
        if lower in ("limits", "allowance", "quota"):
            self._reset_if_new_day(user_id)
            record = self._daily_gifts[user_id]
            fet_used = record["fet"]
            bnb_used = record["bnb"]
            return (
                f"Your daily gift allowance:\\n"
                f"  FET: {fet_used:.2f} / {BUSINESS['daily_gift_limit_fet']:.2f} used\\n"
                f"  BNB: {bnb_used:.6f} / {BUSINESS['daily_gift_limit_bnb']:.6f} used\\n"
                f"Resets at midnight UTC."
            )

        return (
            f"Welcome to {BUSINESS['name']}!\\n\\n"
            f"I distribute testnet FET and BNB to help developers explore AgentLaunch.\\n\\n"
            f"Commands:\\n"
            f"  gift fet <wallet_address> [amount]   — receive testnet FET\\n"
            f"  gift bnb <wallet_address> [amount]   — receive testnet BNB (gas)\\n"
            f"  limits                                — check your daily allowance\\n\\n"
            f"Daily limits: {BUSINESS['daily_gift_limit_fet']} FET, "
            f"{BUSINESS['daily_gift_limit_bnb']} BNB per address\\n\\n"
            f"Platform: agent-launch.ai | Graduation target: 30,000 FET"
        )


# ==============================================================================
# REPLY HELPER
# ==============================================================================


async def reply(ctx: Context, sender: str, text: str, end: bool = False) -> None:
    content = [TextContent(type="text", text=text)]
    if end:
        content.append(EndSessionContent(type="end-session"))
    try:
        await ctx.send(
            sender,
            ChatMessage(timestamp=datetime.utcnow(), msg_id=uuid4(), content=content),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send reply to {sender[:20]}: {e}")


# ==============================================================================
# MAIN AGENT
# ==============================================================================

cache = Cache(max_size=1000)
security = Security()
health = Health()
revenue = Revenue(cache)
business = GifterBusiness()

agent = Agent()
chat_proto = Protocol(spec=chat_protocol_spec)


@chat_proto.on_message(ChatMessage)
async def handle_chat(ctx: Context, sender: str, msg: ChatMessage) -> None:
    try:
        await ctx.send(
            sender,
            ChatAcknowledgement(
                timestamp=datetime.utcnow(), acknowledged_msg_id=msg.msg_id
            ),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send ack to {sender[:20]}: {e}")

    text = " ".join(
        item.text for item in msg.content if isinstance(item, TextContent)
    ).strip()
    text = text[: BUSINESS["max_input_length"]]

    clean, error = security.check(ctx, sender, text)
    if error:
        health.record(False)
        await reply(ctx, sender, error, end=True)
        return

    Logger.audit(ctx, sender, "request")

    lower = clean.lower()

    if lower in ("help", "?"):
        tier = revenue.get_tier(sender)
        await reply(
            ctx,
            sender,
            f"**{BUSINESS['name']}** v{BUSINESS['version']}\\n\\n"
            f"{BUSINESS['description']}\\n\\n"
            f"Your tier: {tier.upper()}\\n\\n"
            f"Commands: help, status, tokenize, gift fet <addr>, gift bnb <addr>, limits",
        )
        return

    if lower == "status":
        s = health.status()
        await reply(
            ctx,
            sender,
            f"Status: {s['status']} | Uptime: {s['uptime_seconds']}s | "
            f"Requests: {s['requests']} | Error rate: {s['error_rate']}",
        )
        return

    if "tokenize" in lower:
        if OWNER_ADDRESS and sender != OWNER_ADDRESS:
            await reply(ctx, sender, "Only the agent owner can trigger tokenization.", end=True)
            return
        result = AgentLaunch.tokenize()
        link = result.get("data", {}).get("handoff_link") or result.get("handoff_link")
        await reply(
            ctx,
            sender,
            f"Token created! Deploy here: {link}" if link else f"Result: {json.dumps(result)}",
            end=True,
        )
        return

    tier = revenue.get_tier(sender)
    allowed, quota_error = revenue.check_quota(sender, tier)
    if not allowed:
        health.record(False)
        await reply(ctx, sender, quota_error, end=True)
        return

    try:
        response = await business.handle(ctx, sender, clean, tier)
        health.record(True)
    except Exception as e:
        health.record(False)
        Logger.error(ctx, "business_handle", str(e))
        response = "Something went wrong. Please try again."

    await reply(ctx, sender, response, end=True)


@chat_proto.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement) -> None:
    ctx.logger.debug(f"Ack from {sender[:20]} for msg {msg.acknowledged_msg_id}")


@agent.on_interval(period=3600)
async def periodic_health(ctx: Context) -> None:
    ctx.logger.info(f"[HEALTH] {json.dumps(health.status())}")


agent.include(chat_proto, publish_manifest=True)

if __name__ == "__main__":
    agent.run()
`,
};
