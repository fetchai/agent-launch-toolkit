/**
 * genesis.ts — Genesis Network template: full commerce stack for agent swarms
 *
 * This is the flagship template for the AgentLaunch platform. It generates a
 * production-ready agent with an inline commerce engine: payments, pricing,
 * tiers, revenue tracking, self-awareness (own token metrics), and cross-holdings.
 *
 * Layers (bottom to top):
 *   1. Logger       — structured logging with audit trail
 *   2. Security     — rate limiting, input validation
 *   3. Health       — uptime, error rate tracking
 *   4. Cache        — in-memory TTL cache
 *   5. Revenue/Tier — PricingTable, TierManager
 *   6. Commerce     — PaymentService, WalletManager, RevenueTracker
 *   7. SelfAware    — token price/holder awareness
 *   8. Holdings     — HoldingsManager for cross-token operations
 *   9. SwarmBusiness — YOUR LOGIC HERE
 *
 * Platform constants (source of truth: deployed smart contracts):
 *   - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
 *   - Graduation target: 30,000 FET -> auto DEX listing
 *   - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)
 */

import type { AgentTemplate } from "../registry.js";

// Environment-based URL resolution (production is default, set AGENT_LAUNCH_ENV=dev for dev)
const PROD_API_URL = 'https://agent-launch.ai/api';
const DEV_API_URL = 'https://launchpad-backend-dev-1056182620041.us-central1.run.app';
const RESOLVED_API_URL = process.env.AGENT_LAUNCH_API_URL ??
  (process.env.AGENT_LAUNCH_ENV === 'dev' ? DEV_API_URL : PROD_API_URL);

export const template: AgentTemplate = {
  name: "genesis",
  description:
    "Full commerce stack for agent swarms — payments, tiers, revenue, self-awareness, cross-holdings",
  category: "Genesis Network",
  variables: [
    { name: "agent_name", required: true, description: "Name of the agent" },
    {
      name: "description",
      default: "A Genesis Network agent",
      description: "Short description of what this agent does",
    },
    {
      name: "role",
      default: "custom",
      description:
        "Agent role: oracle, brain, analyst, coordinator, sentinel, launcher, scout, or custom",
    },
    {
      name: "service_price_afet",
      default: "1000000000000000",
      description: "Price per service call in atestfet (default 0.001 FET)",
    },
    {
      name: "interval_seconds",
      default: "300",
      description: "Background task interval in seconds",
    },
    {
      name: "token_address",
      default: "",
      description: "Own token contract address for self-awareness (empty to disable)",
    },
    {
      name: "premium_token_threshold",
      default: "1000",
      description: "Tokens needed for premium tier access",
    },
    {
      name: "effort_mode",
      default: "normal",
      description: "Initial effort mode: normal, boost, or conserve",
    },
    {
      name: "rate_limit_per_minute",
      default: "10",
      description: "Max requests per user per minute",
    },
    {
      name: "free_requests_per_day",
      default: "10",
      description: "Free-tier daily request limit",
    },
  ],
  dependencies: ["requests", "web3"],
  secrets: [
    "AGENTVERSE_API_KEY",
    "AGENTLAUNCH_API_KEY",
    "AGENT_ADDRESS",
    "AGENT_OWNER_ADDRESS",
    "BSC_PRIVATE_KEY",
  ],
  code: `#!/usr/bin/env python3
"""
{{agent_name}} — Genesis Network Agent (role: {{role}})

{{description}}

Generated by: agentlaunch scaffold {{agent_name}} --type genesis

Commerce layers (inline):
  1. Logger       — structured logging with audit trail
  2. Security     — rate limiting, input validation
  3. Health       — uptime, error rate tracking
  4. Cache        — in-memory TTL cache
  5. Revenue/Tier — PricingTable, TierManager (token-gated access)
  6. Commerce     — PaymentService, WalletManager, RevenueTracker
  7. SelfAware    — own token price/holder awareness
  8. Holdings     — cross-token operations via web3 or handoff links
  9. SwarmBusiness — YOUR LOGIC HERE

Platform constants (source of truth: deployed smart contracts):
  - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
  - Graduation target: 30,000 FET -> auto DEX listing
  - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)
"""

from uagents import Agent, Context, Protocol, Model
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    EndSessionContent,
    TextContent,
    chat_protocol_spec,
)

import json
import os
import time
from collections import defaultdict
from datetime import datetime, date
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

import requests

# ==========================================================================
# COM-01: Payment Protocol — try official, fallback to custom models
# ==========================================================================

try:
    from uagents_core.contrib.protocols.payment import (
        RequestPayment,
        CommitPayment,
        CompletePayment,
        RejectPayment,
        CancelPayment,
        Funds,
        payment_protocol_spec,
    )
    PAYMENT_PROTOCOL_AVAILABLE = True
except ImportError:
    PAYMENT_PROTOCOL_AVAILABLE = False

    class Funds(Model):
        denom: str = "atestfet"
        amount: int = 0

    class RequestPayment(Model):
        request_id: str = ""
        amount: int = 0
        denom: str = "atestfet"
        service: str = ""
        recipient: str = ""

    class CommitPayment(Model):
        request_id: str = ""
        tx_hash: str = ""

    class CompletePayment(Model):
        request_id: str = ""
        result: str = ""

    class RejectPayment(Model):
        request_id: str = ""
        reason: str = ""

    class CancelPayment(Model):
        request_id: str = ""
        reason: str = ""

    payment_protocol_spec = None


# ==========================================================================
# API CONFIG
# ==========================================================================

AGENTLAUNCH_API = os.environ.get("AGENTLAUNCH_API", "${RESOLVED_API_URL}")
OWNER_ADDRESS = os.environ.get("AGENT_OWNER_ADDRESS", "")
TOKEN_ADDRESS = os.environ.get("TOKEN_ADDRESS", "{{token_address}}")

BUSINESS = {
    "name": "{{agent_name}}",
    "description": "{{description}}",
    "role": "{{role}}",
    "version": "1.0.0",
    "service_price_afet": int("{{service_price_afet}}"),
    "interval_seconds": int("{{interval_seconds}}"),
    "premium_token_threshold": int("{{premium_token_threshold}}"),
    "effort_mode": "{{effort_mode}}",
    "rate_limit_per_minute": int("{{rate_limit_per_minute}}"),
    "free_requests_per_day": int("{{free_requests_per_day}}"),
    "max_input_length": 5000,
}

# FETAgentCoin contract ABI — the token IS the bonding curve
TOKEN_ABI = [
    {"name": "buyTokens", "type": "function",
     "inputs": [{"name": "buyer", "type": "address"},
                {"name": "slippageAmount", "type": "uint256"},
                {"name": "_buyAmount", "type": "uint256"}],
     "outputs": [], "stateMutability": "nonpayable"},
    {"name": "sellTokens", "type": "function",
     "inputs": [{"name": "tokenAmount", "type": "uint256"}],
     "outputs": [], "stateMutability": "nonpayable"},
    {"name": "FET_TOKEN", "type": "function",
     "inputs": [], "outputs": [{"name": "", "type": "address"}],
     "stateMutability": "view"},
    {"name": "calculateTokensReceived", "type": "function",
     "inputs": [{"name": "fetAmount", "type": "uint256"}],
     "outputs": [{"name": "", "type": "uint256"}],
     "stateMutability": "view"},
]

ERC20_ABI = [
    {"name": "approve", "type": "function",
     "inputs": [{"name": "spender", "type": "address"},
                {"name": "amount", "type": "uint256"}],
     "outputs": [{"name": "", "type": "bool"}], "stateMutability": "nonpayable"},
    {"name": "allowance", "type": "function",
     "inputs": [{"name": "owner", "type": "address"},
                {"name": "spender", "type": "address"}],
     "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view"},
    {"name": "balanceOf", "type": "function",
     "inputs": [{"name": "account", "type": "address"}],
     "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view"},
    {"name": "decimals", "type": "function",
     "inputs": [], "outputs": [{"name": "", "type": "uint8"}],
     "stateMutability": "view"},
    {"name": "transfer", "type": "function",
     "inputs": [{"name": "to", "type": "address"},
                {"name": "value", "type": "uint256"}],
     "outputs": [{"name": "", "type": "bool"}], "stateMutability": "nonpayable"},
]

# Default TFET address on BSC Testnet
TFET_ADDRESS = "0x304ddf3eE068c53514f782e2341B71A80c8aE3C7"


# ==========================================================================
# LAYER 1: LOGGER — structured logging with audit trail
# ==========================================================================


class Logger:
    @staticmethod
    def info(ctx: Context, event: str, data: Optional[Dict] = None) -> None:
        ctx.logger.info(f"[{event}] {json.dumps(data or {})}")

    @staticmethod
    def audit(ctx: Context, user: str, action: str) -> None:
        ctx.logger.info(
            f"[AUDIT] user={user[:20]} action={action} "
            f"ts={datetime.now().isoformat()}"
        )

    @staticmethod
    def error(ctx: Context, event: str, error: str) -> None:
        ctx.logger.error(f"[{event}] {error}")


# ==========================================================================
# LAYER 2: SECURITY — rate limiting, input validation
# ==========================================================================


class Security:
    def __init__(self) -> None:
        self._requests: Dict[str, List[float]] = defaultdict(list)
        self._check_count: int = 0

    def check(self, ctx: Context, user_id: str, message: str) -> Tuple[Optional[str], Optional[str]]:
        now = time.time()

        # Sliding window rate limit
        self._requests[user_id] = [
            t for t in self._requests[user_id] if now - t < 60
        ]
        if len(self._requests[user_id]) >= BUSINESS["rate_limit_per_minute"]:
            return None, "Rate limit exceeded. Please wait a moment."
        self._requests[user_id].append(now)

        # Periodic cleanup
        self._check_count += 1
        if self._check_count % 100 == 0:
            stale = [
                k for k, v in self._requests.items()
                if not v or (now - max(v)) > 300
            ]
            for k in stale:
                del self._requests[k]

        # Input validation
        if not message or not message.strip():
            return None, "Empty message."
        if len(message) > BUSINESS["max_input_length"]:
            return None, f"Message too long (max {BUSINESS['max_input_length']} chars)."

        return message.strip(), None


# ==========================================================================
# LAYER 3: HEALTH — uptime, error rate tracking
# ==========================================================================


class Health:
    def __init__(self) -> None:
        self._start: datetime = datetime.now()
        self._requests: int = 0
        self._errors: int = 0

    def record(self, success: bool) -> None:
        self._requests += 1
        if not success:
            self._errors += 1

    def status(self) -> Dict[str, Any]:
        uptime = (datetime.now() - self._start).total_seconds()
        error_rate = (self._errors / self._requests * 100) if self._requests else 0
        return {
            "status": "healthy" if error_rate < 10 else "degraded",
            "uptime_seconds": int(uptime),
            "requests": self._requests,
            "error_rate": f"{error_rate:.1f}%",
        }


# ==========================================================================
# LAYER 4: CACHE — in-memory TTL cache
# ==========================================================================


class Cache:
    def __init__(self, max_size: int = 1000) -> None:
        self._data: Dict[str, tuple] = {}
        self._max_size: int = max_size

    def get(self, key: str) -> Any:
        if key in self._data:
            value, expires = self._data[key]
            if expires > time.time():
                return value
            del self._data[key]
        return None

    def set(self, key: str, value: Any, ttl: int = 300) -> None:
        if len(self._data) >= self._max_size:
            now = time.time()
            expired = [k for k, (_, exp) in self._data.items() if exp <= now]
            for k in expired:
                del self._data[k]
            if len(self._data) >= self._max_size:
                to_drop = sorted(self._data.items(), key=lambda x: x[1][1])[
                    : self._max_size // 10
                ]
                for k, _ in to_drop:
                    del self._data[k]
        self._data[key] = (value, time.time() + ttl)


# ==========================================================================
# LAYER 5: REVENUE/TIER — PricingTable + TierManager (COM-03)
# ==========================================================================


class PricingTable:
    """Per-service pricing stored in ctx.storage."""

    STORAGE_KEY = "pricing_table"

    def get_price(self, ctx: Context, service: str) -> int:
        table = json.loads(ctx.storage.get(self.STORAGE_KEY) or "{}")
        return table.get(service, BUSINESS["service_price_afet"])

    def set_price(self, ctx: Context, service: str, amount_afet: int) -> None:
        table = json.loads(ctx.storage.get(self.STORAGE_KEY) or "{}")
        table[service] = amount_afet
        ctx.storage.set(self.STORAGE_KEY, json.dumps(table))

    def list_services(self, ctx: Context) -> Dict[str, int]:
        table = json.loads(ctx.storage.get(self.STORAGE_KEY) or "{}")
        if not table:
            table["default"] = BUSINESS["service_price_afet"]
        return table


class TierManager:
    """Checks token holdings via AgentLaunch API. Returns free or premium."""

    def __init__(self, cache: Cache) -> None:
        self._cache = cache

    def get_tier(self, sender: str) -> str:
        if not TOKEN_ADDRESS:
            return "free"
        cached = self._cache.get(f"tier:{sender}")
        if cached is not None:
            return cached
        try:
            r = requests.get(
                f"{AGENTLAUNCH_API}/agents/token/{TOKEN_ADDRESS}/holders",
                timeout=5,
            )
            if r.status_code == 200:
                holders = r.json() if isinstance(r.json(), list) else r.json().get("holders", [])
                for h in holders:
                    addr = h.get("address", h.get("holder", ""))
                    if addr.lower() == sender.lower():
                        balance = int(h.get("balance", h.get("amount", 0)))
                        tier = "premium" if balance >= BUSINESS["premium_token_threshold"] else "free"
                        self._cache.set(f"tier:{sender}", tier, ttl=300)
                        return tier
        except Exception:
            pass
        self._cache.set(f"tier:{sender}", "free", ttl=300)
        return "free"

    def check_quota(self, user_id: str, tier: str, usage: Dict) -> Tuple[bool, Optional[str]]:
        today = date.today().isoformat()
        user_usage = usage.get(user_id, [])
        user_usage = [t for t in user_usage if t.startswith(today)]
        usage[user_id] = user_usage
        today_count = len(user_usage)
        limit = 10000 if tier == "premium" else BUSINESS["free_requests_per_day"]
        if today_count >= limit:
            if tier == "free":
                return False, (
                    f"Free limit reached ({limit}/day). "
                    f"Hold {BUSINESS['premium_token_threshold']} tokens for premium!"
                )
            return False, f"Daily limit reached ({limit}/day)."
        user_usage.append(datetime.now().isoformat())
        usage[user_id] = user_usage
        return True, None


# ==========================================================================
# LAYER 6: COMMERCE — PaymentService, WalletManager, RevenueTracker (COM-02/04)
# ==========================================================================


class PaymentService:
    """Seller-side payment handling. Tracks pending requests and transaction log."""

    def __init__(self, pricing: PricingTable) -> None:
        self._pricing = pricing
        self._pending: Dict[str, dict] = {}

    async def charge(
        self, ctx: Context, sender: str, amount_afet: int, service: str
    ) -> str:
        request_id = str(uuid4())
        self._pending[request_id] = {
            "sender": sender,
            "amount": amount_afet,
            "service": service,
            "ts": datetime.now().isoformat(),
        }
        msg = RequestPayment(
            request_id=request_id,
            amount=amount_afet,
            denom="atestfet",
            service=service,
            recipient=str(ctx.wallet.address()) if hasattr(ctx, "wallet") else "",
        )
        await ctx.send(sender, msg)
        Logger.info(ctx, "CHARGE_SENT", {"to": sender[:20], "amount": amount_afet, "service": service})
        return request_id

    async def on_commit(self, ctx: Context, sender: str, msg) -> Optional[dict]:
        request_id = getattr(msg, "request_id", "")
        if request_id not in self._pending:
            Logger.error(ctx, "UNKNOWN_PAYMENT", f"request_id={request_id}")
            return None
        pending = self._pending.pop(request_id)
        # Log the transaction
        tx_log = json.loads(ctx.storage.get("tx_log") or "[]")
        tx_log.append({
            "type": "income",
            "request_id": request_id,
            "sender": sender[:20],
            "amount": pending["amount"],
            "service": pending["service"],
            "tx_hash": getattr(msg, "tx_hash", ""),
            "ts": datetime.now().isoformat(),
        })
        ctx.storage.set("tx_log", json.dumps(tx_log[-1000:]))
        Logger.info(ctx, "PAYMENT_RECEIVED", {"from": sender[:20], "amount": pending["amount"]})
        return pending

    def get_balance(self, ctx: Context) -> int:
        try:
            if hasattr(ctx, "ledger") and hasattr(ctx, "wallet"):
                balance = ctx.ledger.query_bank_balance(
                    str(ctx.wallet.address()), "atestfet"
                )
                return int(balance)
        except Exception:
            pass
        return 0


class WalletManager:
    """Balance queries and fund alerts."""

    def get_balance(self, ctx: Context) -> int:
        try:
            if hasattr(ctx, "ledger") and hasattr(ctx, "wallet"):
                return int(ctx.ledger.query_bank_balance(
                    str(ctx.wallet.address()), "atestfet"
                ))
        except Exception:
            pass
        return 0

    def get_address(self, ctx: Context) -> str:
        try:
            if hasattr(ctx, "wallet"):
                return str(ctx.wallet.address())
        except Exception:
            pass
        return ""

    def fund_check(self, ctx: Context, min_balance: int = 10_000_000_000_000_000) -> bool:
        balance = self.get_balance(ctx)
        if balance < min_balance:
            Logger.info(ctx, "LOW_FUNDS", {
                "balance": balance,
                "min_required": min_balance,
                "deficit": min_balance - balance,
            })
            return False
        return True


class RevenueTracker:
    """Income/expense log in ctx.storage."""

    STORAGE_KEY = "revenue_log"

    def record_income(
        self, ctx: Context, amount: int, source: str, service: str
    ) -> None:
        log = json.loads(ctx.storage.get(self.STORAGE_KEY) or "[]")
        log.append({
            "type": "income",
            "amount": amount,
            "source": source[:20],
            "service": service,
            "ts": datetime.now().isoformat(),
        })
        ctx.storage.set(self.STORAGE_KEY, json.dumps(log[-5000:]))

    def record_expense(
        self, ctx: Context, amount: int, dest: str, service: str
    ) -> None:
        log = json.loads(ctx.storage.get(self.STORAGE_KEY) or "[]")
        log.append({
            "type": "expense",
            "amount": amount,
            "dest": dest[:20],
            "service": service,
            "ts": datetime.now().isoformat(),
        })
        ctx.storage.set(self.STORAGE_KEY, json.dumps(log[-5000:]))

    def get_summary(self, ctx: Context) -> Dict[str, Any]:
        log = json.loads(ctx.storage.get(self.STORAGE_KEY) or "[]")
        total_income = sum(e["amount"] for e in log if e["type"] == "income")
        total_expense = sum(e["amount"] for e in log if e["type"] == "expense")
        return {
            "total_income_afet": total_income,
            "total_expense_afet": total_expense,
            "net_afet": total_income - total_expense,
            "tx_count": len(log),
        }

    def get_daily_summary(self, ctx: Context) -> Dict[str, Any]:
        log = json.loads(ctx.storage.get(self.STORAGE_KEY) or "[]")
        today = date.today().isoformat()
        today_entries = [e for e in log if e["ts"].startswith(today)]
        income = sum(e["amount"] for e in today_entries if e["type"] == "income")
        expense = sum(e["amount"] for e in today_entries if e["type"] == "expense")
        return {
            "date": today,
            "income_afet": income,
            "expense_afet": expense,
            "net_afet": income - expense,
            "tx_count": len(today_entries),
        }


# ==========================================================================
# LAYER 7: SELF-AWARE — own token price/holder awareness (COM-05)
# ==========================================================================


class SelfAwareMixin:
    """Reads own token price + holders from AgentLaunch API."""

    HISTORY_KEY = "price_history"

    def __init__(self, cache: Cache) -> None:
        self._cache = cache
        self._price: float = 0.0
        self._holders: int = 0
        self._market_cap: float = 0.0
        self._ma_7d: float = 0.0
        self._effort_mode: str = BUSINESS["effort_mode"]

    def update(self, ctx: Context) -> None:
        if not TOKEN_ADDRESS:
            return
        cached = self._cache.get("self_aware_data")
        if cached:
            self._price, self._holders, self._market_cap = cached
            self._update_effort()
            return
        try:
            r = requests.get(
                f"{AGENTLAUNCH_API}/tokens/address/{TOKEN_ADDRESS}",
                timeout=5,
            )
            if r.status_code == 200:
                data = r.json()
                token = data if "price" in data else data.get("token", data.get("data", {}))
                self._price = float(token.get("price", token.get("currentPrice", 0)))
                self._holders = int(token.get("holders", token.get("holderCount", 0)))
                self._market_cap = float(token.get("marketCap", token.get("market_cap", 0)))
                self._cache.set("self_aware_data", (self._price, self._holders, self._market_cap), ttl=60)

                # Store price history (up to 30 days of hourly samples)
                history = json.loads(ctx.storage.get(self.HISTORY_KEY) or "[]")
                history.append({
                    "price": self._price,
                    "holders": self._holders,
                    "ts": datetime.now().isoformat(),
                })
                history = history[-720:]  # 30 days * 24 hours
                ctx.storage.set(self.HISTORY_KEY, json.dumps(history))

                # Calculate 7-day moving average
                recent = history[-168:]  # 7 days * 24 hours
                if recent:
                    self._ma_7d = sum(p["price"] for p in recent) / len(recent)

                self._update_effort()
                Logger.info(ctx, "SELF_AWARE_UPDATE", {
                    "price": self._price,
                    "holders": self._holders,
                    "ma_7d": round(self._ma_7d, 8),
                    "effort": self._effort_mode,
                })
        except Exception as e:
            Logger.error(ctx, "SELF_AWARE_FETCH", str(e))

    def _update_effort(self) -> None:
        if self._ma_7d <= 0:
            self._effort_mode = BUSINESS["effort_mode"]
            return
        ratio = self._price / self._ma_7d if self._ma_7d > 0 else 1.0
        if ratio > 1.1:
            self._effort_mode = "boost"
        elif ratio < 0.9:
            self._effort_mode = "conserve"
        else:
            self._effort_mode = "normal"

    def get_effort_mode(self) -> str:
        return self._effort_mode

    def get_token_summary(self) -> Dict[str, Any]:
        return {
            "token_address": TOKEN_ADDRESS,
            "price": self._price,
            "holders": self._holders,
            "market_cap": self._market_cap,
            "ma_7d": round(self._ma_7d, 8),
            "effort_mode": self._effort_mode,
        }


# ==========================================================================
# LAYER 8: CROSS-HOLDINGS — HoldingsManager (COM-06)
# ==========================================================================


class HoldingsManager:
    """
    Direct on-chain token operations using web3 + eth_account.
    Fallback: generate handoff links for human signing.
    """

    BSC_RPC = os.environ.get("BSC_RPC", "https://data-seed-prebsc-1-s1.binance.org:8545")
    FRONTEND_URL = os.environ.get("AGENTLAUNCH_FRONTEND", "https://agent-launch.ai")

    def buy_via_web3(
        self, ctx: Context, token_address: str, fet_amount_wei: int,
        slippage_percent: int = 5,
    ) -> Tuple[bool, str]:
        """
        Buy tokens on the bonding curve. The token IS the bonding curve.

        Flow: approve FET -> call buyTokens(buyer, minTokens, fetAmount) on token.
        """
        try:
            from web3 import Web3

            private_key = os.environ.get("BSC_PRIVATE_KEY", "")
            if not private_key:
                return False, self.generate_buy_link(token_address, fet_amount_wei)

            w3 = Web3(Web3.HTTPProvider(self.BSC_RPC))
            if not w3.is_connected():
                return False, "Cannot connect to BSC RPC."

            account = w3.eth.account.from_key(private_key)
            token_addr = Web3.to_checksum_address(token_address)

            token_contract = w3.eth.contract(address=token_addr, abi=TOKEN_ABI)

            # 1. Resolve FET token address from contract (fallback to testnet TFET)
            try:
                fet_addr = token_contract.functions.FET_TOKEN().call()
            except Exception:
                fet_addr = TFET_ADDRESS
            fet_contract = w3.eth.contract(
                address=Web3.to_checksum_address(fet_addr), abi=ERC20_ABI,
            )

            # 2. Check FET balance
            balance = fet_contract.functions.balanceOf(account.address).call()
            if balance < fet_amount_wei:
                return False, (
                    f"Insufficient FET. Have {balance}, need {fet_amount_wei}. "
                    f"Deficit: {fet_amount_wei - balance}"
                )

            nonce = w3.eth.get_transaction_count(account.address)
            gas_price = w3.eth.gas_price
            chain_id = w3.eth.chain_id

            # 3. Approve FET spend on the token contract (if needed)
            allowance = fet_contract.functions.allowance(
                account.address, token_addr,
            ).call()
            if allowance < fet_amount_wei:
                approve_tx = fet_contract.functions.approve(
                    token_addr, fet_amount_wei,
                ).build_transaction({
                    "from": account.address, "nonce": nonce,
                    "gas": 100000, "gasPrice": gas_price, "chainId": chain_id,
                })
                signed_approve = w3.eth.account.sign_transaction(approve_tx, private_key)
                approve_hash = w3.eth.send_raw_transaction(signed_approve.raw_transaction)
                w3.eth.wait_for_transaction_receipt(approve_hash, timeout=60)
                nonce += 1
                Logger.info(ctx, "FET_APPROVED", {
                    "spender": token_address[:12], "amount": fet_amount_wei,
                })

            # 4. Calculate expected tokens and apply slippage
            expected_tokens = token_contract.functions.calculateTokensReceived(
                fet_amount_wei,
            ).call()
            min_tokens = expected_tokens * (100 - slippage_percent) // 100

            # 5. Buy: buyTokens(buyer, slippageAmount, _buyAmount)
            buy_tx = token_contract.functions.buyTokens(
                account.address, min_tokens, fet_amount_wei,
            ).build_transaction({
                "from": account.address, "nonce": nonce,
                "gas": 300000, "gasPrice": gas_price, "chainId": chain_id,
            })
            signed_buy = w3.eth.account.sign_transaction(buy_tx, private_key)
            tx_hash = w3.eth.send_raw_transaction(signed_buy.raw_transaction)

            # 6. Wait for confirmation
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=60)
            if receipt.status != 1:
                return False, f"Buy transaction reverted: {tx_hash.hex()}"

            Logger.info(ctx, "BUY_VIA_WEB3", {
                "token": token_address[:12],
                "fet_spent": fet_amount_wei,
                "expected_tokens": expected_tokens,
                "min_tokens": min_tokens,
                "tx": tx_hash.hex(),
            })
            return True, f"0x{tx_hash.hex()}"

        except ImportError:
            return False, self.generate_buy_link(token_address, fet_amount_wei)
        except Exception as e:
            Logger.error(ctx, "BUY_ERROR", str(e))
            return False, str(e)

    def sell_via_web3(
        self, ctx: Context, token_address: str, token_amount: int,
    ) -> Tuple[bool, str]:
        """
        Sell tokens back to the bonding curve. No approval needed — the token
        contract burns from msg.sender directly.

        Flow: call sellTokens(tokenAmount) on the token contract.
        """
        try:
            from web3 import Web3

            private_key = os.environ.get("BSC_PRIVATE_KEY", "")
            if not private_key:
                return False, self.generate_sell_link(token_address, token_amount)

            w3 = Web3(Web3.HTTPProvider(self.BSC_RPC))
            if not w3.is_connected():
                return False, "Cannot connect to BSC RPC."

            account = w3.eth.account.from_key(private_key)
            token_addr = Web3.to_checksum_address(token_address)

            # 1. Check token balance
            token_contract = w3.eth.contract(address=token_addr, abi=TOKEN_ABI + ERC20_ABI)
            balance = token_contract.functions.balanceOf(account.address).call()
            if balance < token_amount:
                return False, (
                    f"Insufficient tokens. Have {balance}, want to sell {token_amount}."
                )

            # 2. Sell: sellTokens(tokenAmount) — no approval needed
            nonce = w3.eth.get_transaction_count(account.address)
            sell_tx = token_contract.functions.sellTokens(
                token_amount,
            ).build_transaction({
                "from": account.address, "nonce": nonce,
                "gas": 300000, "gasPrice": w3.eth.gas_price,
                "chainId": w3.eth.chain_id,
            })
            signed_sell = w3.eth.account.sign_transaction(sell_tx, private_key)
            tx_hash = w3.eth.send_raw_transaction(signed_sell.raw_transaction)

            # 3. Wait for confirmation
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=60)
            if receipt.status != 1:
                return False, f"Sell transaction reverted: {tx_hash.hex()}"

            Logger.info(ctx, "SELL_VIA_WEB3", {
                "token": token_address[:12],
                "amount": token_amount,
                "tx": tx_hash.hex(),
            })
            return True, f"0x{tx_hash.hex()}"

        except ImportError:
            return False, self.generate_sell_link(token_address, token_amount)
        except Exception as e:
            Logger.error(ctx, "SELL_ERROR", str(e))
            return False, str(e)

    def get_balances(
        self, ctx: Context, token_address: str = "",
    ) -> Dict[str, Any]:
        """Check wallet BNB, FET, and (optionally) token balances."""
        result: Dict[str, Any] = {"bnb": 0, "fet": 0, "token": 0, "wallet": ""}
        try:
            from web3 import Web3

            private_key = os.environ.get("BSC_PRIVATE_KEY", "")
            if not private_key:
                return result

            w3 = Web3(Web3.HTTPProvider(self.BSC_RPC))
            if not w3.is_connected():
                return result

            account = w3.eth.account.from_key(private_key)
            result["wallet"] = account.address

            # BNB balance
            result["bnb"] = w3.eth.get_balance(account.address)

            # FET balance
            try:
                if token_address:
                    tc = w3.eth.contract(
                        address=Web3.to_checksum_address(token_address), abi=TOKEN_ABI,
                    )
                    fet_addr = tc.functions.FET_TOKEN().call()
                else:
                    fet_addr = TFET_ADDRESS
                fet_contract = w3.eth.contract(
                    address=Web3.to_checksum_address(fet_addr), abi=ERC20_ABI,
                )
                result["fet"] = fet_contract.functions.balanceOf(account.address).call()
            except Exception:
                pass

            # Token balance (if address provided)
            if token_address:
                try:
                    token_contract = w3.eth.contract(
                        address=Web3.to_checksum_address(token_address), abi=ERC20_ABI,
                    )
                    result["token"] = token_contract.functions.balanceOf(account.address).call()
                except Exception:
                    pass

        except ImportError:
            pass
        except Exception:
            pass
        return result

    def get_holdings_summary(self, ctx: Context, token_addresses: List[str]) -> List[Dict]:
        results = []
        for addr in token_addresses:
            try:
                r = requests.get(
                    f"{AGENTLAUNCH_API}/tokens/address/{addr}",
                    timeout=5,
                )
                if r.status_code == 200:
                    data = r.json()
                    token = data if "name" in data else data.get("token", data.get("data", {}))
                    results.append({
                        "address": addr,
                        "name": token.get("name", "Unknown"),
                        "price": float(token.get("price", token.get("currentPrice", 0))),
                        "holders": int(token.get("holders", token.get("holderCount", 0))),
                    })
            except Exception:
                results.append({"address": addr, "name": "Error", "price": 0, "holders": 0})
        return results

    @staticmethod
    def generate_buy_link(token_address: str, amount: int = 0) -> str:
        base = os.environ.get("AGENTLAUNCH_FRONTEND", "https://agent-launch.ai")
        url = f"{base}/trade/{token_address}?action=buy"
        if amount:
            url += f"&amount={amount}"
        return f"Sign here: {url}"

    @staticmethod
    def generate_sell_link(token_address: str, amount: int = 0) -> str:
        base = os.environ.get("AGENTLAUNCH_FRONTEND", "https://agent-launch.ai")
        url = f"{base}/trade/{token_address}?action=sell"
        if amount:
            url += f"&amount={amount}"
        return f"Sign here: {url}"


# ==========================================================================
# AGENTLAUNCH INTEGRATION — tokenization via API
# ==========================================================================


class AgentLaunch:
    @staticmethod
    def tokenize() -> Dict:
        agent_address = os.environ.get("AGENT_ADDRESS")
        if not agent_address:
            return {"error": "AGENT_ADDRESS env var not set."}
        try:
            r = requests.post(
                f"{AGENTLAUNCH_API}/agents/tokenize",
                headers={
                    "X-API-Key": os.environ.get("AGENTLAUNCH_API_KEY", ""),
                    "Content-Type": "application/json",
                },
                json={
                    "agentAddress": agent_address,
                    "name": BUSINESS["name"],
                    "description": BUSINESS["description"],
                },
                timeout=30,
            )
            return r.json() if r.status_code in [200, 201] else {"error": r.text}
        except Exception as e:
            return {"error": str(e)}


# ==========================================================================
# REPLY HELPER
# ==========================================================================


async def reply(ctx: Context, sender: str, text: str, end: bool = False) -> None:
    content = [TextContent(type="text", text=text)]
    if end:
        content.append(EndSessionContent(type="end-session"))
    try:
        await ctx.send(
            sender,
            ChatMessage(timestamp=datetime.now(), msg_id=uuid4(), content=content),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send reply to {sender[:20]}: {e}")


# ==========================================================================
# LAYER 9: SWARM BUSINESS — YOUR LOGIC HERE
# ==========================================================================
#
# Everything above is the Genesis commerce stack. Below is where you add
# your agent's unique intelligence. The commerce layers handle payments,
# tiers, and revenue. Focus on what your agent DOES, not how it gets paid.
#
# The default handler below routes standard commands (help, status, tokenize)
# and delegates business queries to the handle_business() function.
#
# Examples of what to add:
#
#   async def handle_business(ctx, sender, message, tier):
#       # Your agent's core logic goes here
#       return "result"
#
#   @agent.on_interval(period=BUSINESS["interval_seconds"])
#   async def background_task(ctx):
#       # Periodic work: monitoring, data collection, alerts
#       pass


async def handle_business(
    ctx: Context, sender: str, message: str, tier: str
) -> str:
    """
    ===================================================================
    YOUR SWARM LOGIC — This is where your agent becomes unique
    ===================================================================

    Add your message handlers, interval tasks, and service logic here.
    The commerce layers above handle payments, tiers, and revenue.
    Focus on what your agent DOES, not how it gets paid.

    Available objects:
        pricing     — PricingTable: get_price(), set_price(), list_services()
        tier_mgr    — TierManager: get_tier(), check_quota()
        payments    — PaymentService: charge(), on_commit(), get_balance()
        wallet      — WalletManager: get_balance(), get_address(), fund_check()
        revenue     — RevenueTracker: record_income/expense(), get_summary()
        self_aware  — SelfAwareMixin: update(), get_effort_mode(), get_token_summary()
        holdings    — HoldingsManager: buy_via_web3(), sell_via_web3(), get_balances(), get_holdings_summary()
        cache       — Cache: get(), set()

    Args:
        ctx: Agent context (has logger, storage, ledger, wallet)
        sender: Address of the message sender
        message: The cleaned user message
        tier: "free" or "premium"

    Returns:
        Response text to send back to the user
    """
    lower = message.lower()

    # Example: price query
    if lower.startswith("price "):
        parts = message.split(maxsplit=1)
        if len(parts) > 1:
            services = pricing.list_services(ctx)
            svc = parts[1].strip()
            if svc in services:
                price = services[svc]
                return f"Service '{svc}' costs {price} atestfet ({price / 1e18:.6f} FET)"
            return f"Unknown service '{svc}'. Available: {', '.join(services.keys())}"
        return "Usage: price <service_name>"

    # Example: list available services
    if lower in ("services", "pricing", "menu"):
        services = pricing.list_services(ctx)
        lines = [f"Available services for {BUSINESS['name']}:"]
        for svc, price in services.items():
            lines.append(f"  {svc}: {price} atestfet ({price / 1e18:.6f} FET)")
        lines.append(f"\\nYour tier: {tier.upper()}")
        return "\\n".join(lines)

    # Example: revenue summary (owner only)
    if lower == "revenue" and (not OWNER_ADDRESS or sender == OWNER_ADDRESS):
        summary = revenue.get_summary(ctx)
        daily = revenue.get_daily_summary(ctx)
        return (
            f"Revenue Summary:\\n"
            f"  All-time income: {summary['total_income_afet']} atestfet\\n"
            f"  All-time expense: {summary['total_expense_afet']} atestfet\\n"
            f"  Net: {summary['net_afet']} atestfet\\n"
            f"  Transactions: {summary['tx_count']}\\n\\n"
            f"Today ({daily['date']}):\\n"
            f"  Income: {daily['income_afet']} atestfet\\n"
            f"  Expense: {daily['expense_afet']} atestfet"
        )

    # Example: token self-awareness
    if lower in ("token", "self", "awareness"):
        if TOKEN_ADDRESS:
            s = self_aware.get_token_summary()
            return (
                f"Token Status:\\n"
                f"  Address: {s['token_address'][:16]}...\\n"
                f"  Price: {s['price']:.8f} FET\\n"
                f"  Holders: {s['holders']}\\n"
                f"  7d MA: {s['ma_7d']:.8f} FET\\n"
                f"  Market Cap: {s.get('market_cap', 0):.2f} FET\\n"
                f"  Effort Mode: {s['effort_mode'].upper()}"
            )
        return "No token address configured. Set TOKEN_ADDRESS to enable self-awareness."

    # Default: echo with role context
    return (
        f"I am {BUSINESS['name']} (role: {BUSINESS['role']}).\\n"
        f"Type 'help' for commands, 'services' for pricing, or ask me anything.\\n\\n"
        f"Your message: {message[:200]}"
    )


# ==========================================================================
# MAIN AGENT SETUP
# ==========================================================================

cache = Cache(max_size=2000)
security = Security()
health = Health()
pricing = PricingTable()
tier_mgr = TierManager(cache)
payments = PaymentService(pricing)
wallet = WalletManager()
revenue = RevenueTracker()
self_aware = SelfAwareMixin(cache)
holdings = HoldingsManager()

# Usage tracking for quota enforcement
_usage: Dict[str, List[str]] = defaultdict(list)

agent = Agent()
chat_proto = Protocol(spec=chat_protocol_spec)

# Payment protocol (seller side)
if PAYMENT_PROTOCOL_AVAILABLE and payment_protocol_spec is not None:
    pay_proto = agent.create_protocol(spec=payment_protocol_spec, role="seller")
else:
    pay_proto = Protocol(name="payment", version="1.0.0")


# ==========================================================================
# CHAT PROTOCOL HANDLER
# ==========================================================================


@chat_proto.on_message(ChatMessage)
async def handle_chat(ctx: Context, sender: str, msg: ChatMessage) -> None:
    # 1. Acknowledge receipt
    try:
        await ctx.send(
            sender,
            ChatAcknowledgement(
                timestamp=datetime.now(), acknowledged_msg_id=msg.msg_id
            ),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send ack to {sender[:20]}: {e}")

    # 2. Extract text
    text = " ".join(
        item.text for item in msg.content if isinstance(item, TextContent)
    ).strip()
    text = text[: BUSINESS["max_input_length"]]

    # 3. Security check (rate limit + validation)
    clean, error = security.check(ctx, sender, text)
    if error:
        health.record(False)
        await reply(ctx, sender, error, end=True)
        return

    Logger.audit(ctx, sender, "request")
    lower = clean.lower()

    # 4. Built-in commands
    if lower in ("help", "?"):
        tier = tier_mgr.get_tier(sender)
        effort = self_aware.get_effort_mode()
        await reply(
            ctx,
            sender,
            f"**{BUSINESS['name']}** v{BUSINESS['version']} "
            f"(role: {BUSINESS['role']}, effort: {effort})\\n\\n"
            f"{BUSINESS['description']}\\n\\n"
            f"Your tier: {tier.upper()}\\n\\n"
            f"Commands:\\n"
            f"  help       — this message\\n"
            f"  status     — health, uptime, error rate\\n"
            f"  services   — available services and pricing\\n"
            f"  token      — token price and holder stats\\n"
            f"  revenue    — revenue summary (owner only)\\n"
            f"  tokenize   — create token (owner only)\\n"
            f"  <query>    — ask the agent anything",
        )
        return

    if lower == "status":
        s = health.status()
        w = wallet.get_balance(ctx)
        effort = self_aware.get_effort_mode()
        await reply(
            ctx,
            sender,
            f"Status: {s['status']} | Uptime: {s['uptime_seconds']}s | "
            f"Requests: {s['requests']} | Error rate: {s['error_rate']} | "
            f"Balance: {w} atestfet | Effort: {effort}",
        )
        return

    if "tokenize" in lower:
        if OWNER_ADDRESS and sender != OWNER_ADDRESS:
            await reply(ctx, sender, "Only the agent owner can trigger tokenization.", end=True)
            return
        result = AgentLaunch.tokenize()
        link = result.get("data", {}).get("handoff_link") or result.get("handoff_link")
        await reply(
            ctx,
            sender,
            f"Token created! Deploy here: {link}" if link else f"Result: {json.dumps(result)}",
            end=True,
        )
        return

    # 5. Check tier and quota
    tier = tier_mgr.get_tier(sender)
    allowed, quota_error = tier_mgr.check_quota(sender, tier, _usage)
    if not allowed:
        health.record(False)
        await reply(ctx, sender, quota_error, end=True)
        return

    # 6. Delegate to business logic
    try:
        response = await handle_business(ctx, sender, clean, tier)
        health.record(True)
    except Exception as e:
        health.record(False)
        Logger.error(ctx, "BUSINESS_ERROR", str(e))
        response = "Something went wrong. Please try again."

    await reply(ctx, sender, response, end=True)


@chat_proto.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement) -> None:
    ctx.logger.debug(f"Ack from {sender[:20]} for msg {msg.acknowledged_msg_id}")


# ==========================================================================
# PAYMENT PROTOCOL HANDLERS
# ==========================================================================


@pay_proto.on_message(CommitPayment)
async def handle_commit(ctx: Context, sender: str, msg: CommitPayment) -> None:
    pending = await payments.on_commit(ctx, sender, msg)
    if pending:
        revenue.record_income(ctx, pending["amount"], sender, pending["service"])
        await ctx.send(
            sender,
            CompletePayment(request_id=msg.request_id, result="Payment confirmed. Service delivered."),
        )


@pay_proto.on_message(RejectPayment)
async def handle_reject(ctx: Context, sender: str, msg: RejectPayment) -> None:
    Logger.info(ctx, "PAYMENT_REJECTED", {"from": sender[:20], "reason": msg.reason})


if not PAYMENT_PROTOCOL_AVAILABLE:
    @pay_proto.on_message(RequestPayment)
    async def handle_incoming_request(ctx: Context, sender: str, msg: RequestPayment) -> None:
        Logger.info(ctx, "PAYMENT_REQUEST_RECEIVED", {"from": sender[:20], "amount": msg.amount})


# ==========================================================================
# BACKGROUND TASKS
# ==========================================================================


@agent.on_interval(period=float(BUSINESS["interval_seconds"]))
async def background_task(ctx: Context) -> None:
    """Periodic self-awareness update and health check."""
    self_aware.update(ctx)
    wallet.fund_check(ctx)
    ctx.logger.info(f"[HEALTH] {json.dumps(health.status())}")


# ==========================================================================
# WIRE UP
# ==========================================================================

agent.include(chat_proto, publish_manifest=True)
agent.include(pay_proto, publish_manifest=True)

if __name__ == "__main__":
    agent.run()
`,
};
