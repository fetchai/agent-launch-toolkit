/**
 * CLI-002 + CLI-006: create command
 *
 * agentlaunch create [--name "My Agent"] [--ticker MYAG] [--template custom]
 *                    [--description "..."] [--chain 97] [--deploy] [--tokenize] [--json]
 *
 * Flagship one-command flow:
 *   1. Scaffold agent project (always)
 *   2. Deploy to Agentverse (if --deploy)
 *   3. Tokenize on AgentLaunch (if --tokenize)
 *   4. Print handoff link
 *
 * When name/ticker are omitted, uses readline for interactive prompts.
 *
 * Platform constants (source of truth: deployed smart contracts):
 *   - Deploy fee:          120 FET (read dynamically, can change via multi-sig)
 *   - Graduation target:   30,000 FET -> auto DEX listing
 *   - Trading fee:         2% -> 100% to protocol treasury (NO creator fee)
 */

import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import readline from "node:readline";
import { Command } from "commander";
import { agentverseRequest, apiPost } from "../http.js";
import { requireApiKey } from "../config.js";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

type TemplateId = "custom" | "faucet" | "research" | "trading" | "data";

const TEMPLATES: Record<TemplateId, { label: string; description: string }> = {
  custom: {
    label: "Custom",
    description: "Blank slate — add your own business logic",
  },
  faucet: {
    label: "Faucet",
    description: "Distributes testnet FET and BNB to new developers",
  },
  research: {
    label: "Research",
    description: "Delivers on-demand research reports and analysis",
  },
  trading: {
    label: "Trading",
    description: "Monitors token prices and sends trade alerts",
  },
  data: {
    label: "Data Feed",
    description: "Serves structured data feeds and query results",
  },
};

const TEMPLATE_LIST = Object.entries(TEMPLATES) as [
  TemplateId,
  (typeof TEMPLATES)[TemplateId],
][];

interface TokenizeResponse {
  token_id?: number;
  tokenId?: number;
  token_address?: string;
  handoff_link?: string;
  data?: { token_id?: number; handoff_link?: string };
  message?: string;
}

interface AgentCreatedResponse {
  address: string;
  wallet_address?: string;
}

interface AgentStatusResponse {
  compiled?: boolean;
  running?: boolean;
  wallet_address?: string;
}

interface CodeUploadResponse {
  digest?: string;
}

interface CreateResult {
  name: string;
  ticker: string;
  template: TemplateId;
  scaffoldDir?: string;
  agentAddress?: string;
  walletAddress?: string;
  tokenId?: number;
  tokenAddress?: string;
  handoffLink?: string;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function prompt(rl: readline.Interface, question: string): Promise<string> {
  return new Promise((resolve) => rl.question(question, resolve));
}

function sanitizeDirName(s: string): string {
  return s.replace(/[^a-zA-Z0-9_-]/g, "-").toLowerCase();
}

function toPascalCase(s: string): string {
  return s
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, c: string) => c.toUpperCase())
    .replace(/^(.)/, (c: string) => c.toUpperCase());
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// ---------------------------------------------------------------------------
// Scaffold to a temp or target directory
// ---------------------------------------------------------------------------

function scaffoldAgent(
  name: string,
  template: TemplateId,
  description: string,
  targetDir: string,
): void {
  const meta = TEMPLATES[template];
  const className = toPascalCase(name);
  const desc = description || meta.description;

  const agentPy = `#!/usr/bin/env python3
"""
${name} — AgentLaunch Agent
Template: ${meta.label}
Generated by: agentlaunch create

Platform constants (source of truth: deployed smart contracts):
  - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
  - Graduation target: 30,000 FET -> auto DEX listing
  - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)
"""

from uagents import Agent, Context, Protocol
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    EndSessionContent,
    TextContent,
    chat_protocol_spec,
)

import json
import os
from datetime import datetime
from uuid import uuid4

AGENTLAUNCH_API = os.environ.get("AGENTLAUNCH_API", "${SCAFFOLD_API_URL}")

BUSINESS = {
    "name": "${name}",
    "description": "${desc}",
    "version": "1.0.0",
}


class ${className}Business:
    """Customize this for your ${template} agent."""

    async def handle(self, ctx: Context, user_id: str, message: str) -> str:
        safe = message.replace("\\n", " ")[:500]
        return (
            f"Hello from {BUSINESS['name']}! You said: {safe}\\n\\n"
            "This is a scaffold — edit ${className}Business.handle() to add your logic."
        )


async def reply(ctx: Context, sender: str, text: str, end: bool = False) -> None:
    content = [TextContent(type="text", text=text)]
    if end:
        content.append(EndSessionContent(type="end-session"))
    await ctx.send(
        sender,
        ChatMessage(timestamp=datetime.utcnow(), msg_id=uuid4(), content=content),
    )


business = ${className}Business()
agent = Agent()
chat_proto = Protocol(spec=chat_protocol_spec)


@chat_proto.on_message(ChatMessage)
async def handle_chat(ctx: Context, sender: str, msg: ChatMessage) -> None:
    await ctx.send(
        sender,
        ChatAcknowledgement(
            timestamp=datetime.utcnow(), acknowledged_msg_id=msg.msg_id
        ),
    )
    text = " ".join(
        item.text for item in msg.content if isinstance(item, TextContent)
    ).strip()
    response = await business.handle(ctx, sender, text)
    await reply(ctx, sender, response, end=True)


@chat_proto.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement) -> None:
    ctx.logger.debug(f"Ack from {sender[:20]}")


agent.include(chat_proto, publish_manifest=True)

if __name__ == "__main__":
    agent.run()
`;

  const readmeMd = `# ${name}

AgentLaunch Agent — generated by \`agentlaunch create\`.

## Quickstart

\`\`\`bash
pip install uagents uagents-core requests
cp .env.example .env
# Edit .env, then:
python agent.py
\`\`\`

## Platform Constants

- Deploy fee: **120 FET** (read dynamically from contract)
- Graduation target: **30,000 FET** — auto DEX listing
- Trading fee: **2%** — 100% to protocol treasury (no creator fee)
`;

  const envExample = `# ${name} — Environment Variables
AGENTVERSE_API_KEY=
AGENTLAUNCH_API_KEY=
AGENT_ADDRESS=
AGENT_OWNER_ADDRESS=
`;

  fs.mkdirSync(targetDir, { recursive: true });
  fs.writeFileSync(path.join(targetDir, "agent.py"), agentPy, "utf8");
  fs.writeFileSync(path.join(targetDir, "README.md"), readmeMd, "utf8");
  fs.writeFileSync(path.join(targetDir, ".env.example"), envExample, "utf8");
}

// ---------------------------------------------------------------------------
// Deploy to Agentverse
// ---------------------------------------------------------------------------

const AGENTVERSE_API = "https://agentverse.ai/v1";
const POLL_INTERVAL_MS = 5_000;
const MAX_POLLS = 12;

async function deployToAgentverse(
  agentPyPath: string,
  agentName: string,
  apiKey: string,
  json: boolean,
): Promise<{ agentAddress: string; walletAddress?: string }> {
  const agentCode = fs.readFileSync(agentPyPath, "utf8");

  if (!json) console.log("\n[1/5] Creating agent on Agentverse...");
  const created = await agentverseRequest<AgentCreatedResponse>(
    "POST",
    `${AGENTVERSE_API}/hosting/agents`,
    apiKey,
    { name: agentName.slice(0, 64) },
  );
  const agentAddress = created.address;
  if (!json) console.log(`      Address: ${agentAddress}`);

  if (!json) console.log("[2/5] Uploading code...");
  const codeArray = [{ language: "python", name: "agent.py", value: agentCode }];
  const uploaded = await agentverseRequest<CodeUploadResponse>(
    "PUT",
    `${AGENTVERSE_API}/hosting/agents/${agentAddress}/code`,
    apiKey,
    { code: JSON.stringify(codeArray) },
  );
  if (!json) {
    const digest = uploaded.digest ?? "unknown";
    console.log(`      Digest: ${digest.slice(0, 16)}...`);
  }

  if (!json) console.log("[3/5] Setting secrets...");
  for (const secretName of ["AGENTVERSE_API_KEY", "AGENTLAUNCH_API_KEY"]) {
    try {
      await agentverseRequest(
        "POST",
        `${AGENTVERSE_API}/hosting/secrets`,
        apiKey,
        { address: agentAddress, name: secretName, secret: apiKey },
      );
      if (!json) console.log(`      Set: ${secretName}`);
    } catch {
      if (!json) console.log(`      Warning: Could not set ${secretName}`);
    }
  }

  if (!json) console.log("[4/5] Starting agent...");
  await agentverseRequest(
    "POST",
    `${AGENTVERSE_API}/hosting/agents/${agentAddress}/start`,
    apiKey,
  );
  if (!json) console.log("      Started.");

  if (!json) console.log("[5/5] Waiting for compilation...");
  let walletAddress: string | undefined;

  for (let i = 0; i < MAX_POLLS; i++) {
    await sleep(POLL_INTERVAL_MS);
    try {
      const resp = await fetch(
        `${AGENTVERSE_API}/hosting/agents/${agentAddress}`,
        { headers: { Authorization: `bearer ${apiKey}` } },
      );
      if (resp.ok) {
        const s = (await resp.json()) as AgentStatusResponse;
        if (s.compiled) {
          walletAddress = s.wallet_address;
          if (!json) console.log("      Compiled.");
          break;
        }
      }
    } catch {
      // transient — keep polling
    }
    if (!json) {
      const elapsed = ((i + 1) * POLL_INTERVAL_MS) / 1000;
      console.log(`      Waiting... (${elapsed}s)`);
    }
  }

  return { agentAddress, walletAddress };
}

// ---------------------------------------------------------------------------
// Tokenize
// ---------------------------------------------------------------------------

const DEV_API_URL = 'https://launchpad-backend-dev-1056182620041.us-central1.run.app';
const DEV_FRONTEND_URL = 'https://launchpad-frontend-dev-1056182620041.us-central1.run.app';
const PROD_API_URL = 'https://agent-launch.ai/api';
const PROD_FRONTEND_URL = 'https://agent-launch.ai';

function isProdEnv(): boolean { return process.env.AGENT_LAUNCH_ENV === 'production'; }

function resolveCreateApiUrl(): string {
  if (process.env.AGENT_LAUNCH_API_URL) return process.env.AGENT_LAUNCH_API_URL.replace(/\/$/, '');
  if (process.env.AGENT_LAUNCH_BASE_URL) return process.env.AGENT_LAUNCH_BASE_URL.replace(/\/$/, '');
  return isProdEnv() ? PROD_API_URL : DEV_API_URL;
}

function resolveCreateFrontendUrl(): string {
  if (process.env.AGENT_LAUNCH_FRONTEND_URL) return process.env.AGENT_LAUNCH_FRONTEND_URL.replace(/\/$/, '');
  return isProdEnv() ? PROD_FRONTEND_URL : DEV_FRONTEND_URL;
}

const DEFAULT_BASE_URL = resolveCreateFrontendUrl();
const SCAFFOLD_API_URL = resolveCreateApiUrl();

async function tokenizeAgent(
  agentAddress: string,
  name: string,
  ticker: string,
  description: string,
  chainId: number,
  json: boolean,
): Promise<{ tokenId?: number; tokenAddress?: string; handoffLink?: string }> {
  if (!json) console.log("\nTokenizing agent on AgentLaunch...");

  const result = await apiPost<TokenizeResponse>("/agents/tokenize", {
    agentAddress,
    name,
    symbol: ticker.toUpperCase(),
    description,
    chainId,
  });

  const tokenId =
    result.token_id ?? result.tokenId ?? result.data?.token_id;
  const tokenAddress = result.token_address;
  const handoffLink =
    result.handoff_link ??
    result.data?.handoff_link ??
    (tokenId !== undefined ? `${DEFAULT_BASE_URL}/deploy/${tokenId}` : undefined);

  return { tokenId, tokenAddress, handoffLink };
}

// ---------------------------------------------------------------------------
// Command registration
// ---------------------------------------------------------------------------

export function registerCreateCommand(program: Command): void {
  program
    .command("create")
    .description(
      "Flagship one-command flow: scaffold → deploy → tokenize an AI agent",
    )
    .option("--name <name>", "Agent name (prompted if omitted)")
    .option("--ticker <ticker>", "Token ticker symbol e.g. MYAG (prompted if omitted)")
    .option(
      "--template <template>",
      "Agent template: custom, faucet, research, trading, data (default: custom)",
    )
    .option("--description <desc>", "Token description (max 500 chars)")
    .option(
      "--chain <chainId>",
      "Chain ID: 97 (BSC testnet) or 56 (BSC mainnet) (default: 97)",
      "97",
    )
    .option("--deploy", "Deploy agent to Agentverse after scaffolding")
    .option("--tokenize", "Create token record on AgentLaunch after deploy")
    .option("--json", "Output only JSON (machine-readable, disables prompts)")
    .action(
      async (options: {
        name?: string;
        ticker?: string;
        template?: string;
        description?: string;
        chain: string;
        deploy?: boolean;
        tokenize?: boolean;
        json?: boolean;
      }) => {
        const isJson = options.json === true;

        // When --json is set we never prompt — fail fast with errors
        let name = options.name?.trim() ?? "";
        let ticker = options.ticker?.trim() ?? "";
        let template = (options.template ?? "") as TemplateId;
        let doDeploy = options.deploy === true;
        let doTokenize = options.tokenize === true;

        // Interactive prompts (only when not --json)
        if (!isJson) {
          const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
          });

          if (!name) {
            name = (await prompt(rl, "Agent name: ")).trim();
          }

          if (!ticker) {
            ticker = (await prompt(rl, "Ticker symbol: ")).trim();
          }

          if (!template || !Object.keys(TEMPLATES).includes(template)) {
            console.log("\nAvailable templates:");
            TEMPLATE_LIST.forEach(([id, meta], idx) => {
              console.log(`  ${idx + 1}) ${meta.label.padEnd(12)} — ${meta.description}`);
            });
            const choice = (await prompt(rl, "Template (1-5, default 1): ")).trim();
            const idx = parseInt(choice, 10) - 1;
            template =
              idx >= 0 && idx < TEMPLATE_LIST.length
                ? TEMPLATE_LIST[idx][0]
                : "custom";
          }

          if (!options.deploy) {
            const ans = (
              await prompt(rl, "Deploy to Agentverse? (y/N): ")
            ).trim().toLowerCase();
            doDeploy = ans === "y" || ans === "yes";
          }

          if (!options.tokenize) {
            const ans = (
              await prompt(rl, "Tokenize on AgentLaunch? (y/N): ")
            ).trim().toLowerCase();
            doTokenize = ans === "y" || ans === "yes";
          }

          rl.close();
        }

        // Validate inputs
        const errors: string[] = [];
        if (!name) errors.push("--name is required");
        else if (name.length > 32) errors.push("--name must be 32 characters or fewer");

        if (!ticker) errors.push("--ticker is required");
        else {
          const t = ticker.toUpperCase();
          if (t.length < 2 || t.length > 11) {
            errors.push("--ticker must be 2-11 characters");
          }
        }

        if (!template || !Object.keys(TEMPLATES).includes(template)) {
          template = "custom";
        }

        const chainId = parseInt(options.chain, 10);
        if (![56, 97].includes(chainId)) {
          errors.push("--chain must be 97 (BSC testnet) or 56 (BSC mainnet)");
        }

        if (errors.length > 0) {
          if (isJson) {
            console.log(JSON.stringify({ error: errors.join("; ") }));
          } else {
            errors.forEach((e) => console.error(`Error: ${e}`));
          }
          process.exit(1);
        }

        const result: CreateResult = {
          name,
          ticker: ticker.toUpperCase(),
          template,
        };

        // Step 1: Scaffold
        const dirName = sanitizeDirName(name);
        const targetDir = path.resolve(process.cwd(), dirName);

        if (!isJson) {
          console.log(`\nScaffolding agent: ${name} (${TEMPLATES[template].label})`);
          console.log(`Directory: ${targetDir}`);
        }

        if (fs.existsSync(targetDir)) {
          const msg = `Directory "${dirName}" already exists.`;
          if (isJson) {
            console.log(JSON.stringify({ error: msg }));
          } else {
            console.error(`Error: ${msg}`);
          }
          process.exit(1);
        }

        const description = (options.description ?? TEMPLATES[template].description).slice(0, 500);
        scaffoldAgent(name, template, description, targetDir);
        result.scaffoldDir = targetDir;

        if (!isJson) {
          console.log(`  Created: agent.py`);
          console.log(`  Created: README.md`);
          console.log(`  Created: .env.example`);
        }

        // Step 2: Deploy (optional)
        if (doDeploy) {
          let apiKey: string;
          try {
            apiKey = requireApiKey();
          } catch (err) {
            if (isJson) {
              console.log(JSON.stringify({ error: (err as Error).message }));
            } else {
              console.error((err as Error).message);
            }
            process.exit(1);
          }

          try {
            const agentPyPath = path.join(targetDir, "agent.py");
            const deployed = await deployToAgentverse(agentPyPath, name, apiKey, isJson);
            result.agentAddress = deployed.agentAddress;
            result.walletAddress = deployed.walletAddress;
          } catch (err) {
            if (isJson) {
              console.log(
                JSON.stringify({ error: `Deploy failed: ${(err as Error).message}`, partial: result }),
              );
            } else {
              console.error(`\nDeploy failed: ${(err as Error).message}`);
            }
            process.exit(1);
          }
        }

        // Step 3: Tokenize (optional)
        if (doTokenize) {
          if (!result.agentAddress) {
            if (isJson) {
              console.log(
                JSON.stringify({
                  error: "Cannot tokenize without deploying first. Add --deploy flag.",
                  partial: result,
                }),
              );
            } else {
              console.error(
                "\nError: Cannot tokenize without deploying first. Add --deploy flag.",
              );
            }
            process.exit(1);
          }

          try {
            const tokenized = await tokenizeAgent(
              result.agentAddress,
              name,
              result.ticker,
              description,
              chainId,
              isJson,
            );
            result.tokenId = tokenized.tokenId;
            result.tokenAddress = tokenized.tokenAddress;
            result.handoffLink = tokenized.handoffLink;
          } catch (err) {
            if (isJson) {
              console.log(
                JSON.stringify({ error: `Tokenize failed: ${(err as Error).message}`, partial: result }),
              );
            } else {
              console.error(`\nTokenize failed: ${(err as Error).message}`);
            }
            process.exit(1);
          }
        }

        // Output
        if (isJson) {
          console.log(JSON.stringify(result));
          return;
        }

        console.log(`\n${"=".repeat(50)}`);
        console.log("CREATE COMPLETE");
        console.log(`${"=".repeat(50)}`);
        console.log(`Name:      ${result.name}`);
        console.log(`Ticker:    ${result.ticker}`);
        console.log(`Template:  ${TEMPLATES[result.template].label}`);
        console.log(`Directory: ${result.scaffoldDir}`);

        if (result.agentAddress) {
          console.log(`\nAgent Address: ${result.agentAddress}`);
          if (result.walletAddress) {
            console.log(`Wallet:        ${result.walletAddress}`);
          }
        }

        if (result.tokenId !== undefined) {
          console.log(`\nToken ID:  ${result.tokenId}`);
        }
        if (result.tokenAddress) {
          console.log(`Token:     ${result.tokenAddress}`);
        }
        if (result.handoffLink) {
          console.log(`\nHandoff link (share with a human to deploy on-chain):`);
          console.log(`  ${result.handoffLink}`);
        }

        if (!doDeploy && !doTokenize) {
          console.log(`\nNext steps:`);
          console.log(`  cd ${dirName}`);
          console.log(`  cp .env.example .env  # fill in your API keys`);
          console.log(`  agentlaunch deploy    # deploy to Agentverse`);
          console.log(
            `  agentlaunch tokenize --agent <address> --name "${name}" --symbol ${result.ticker}`,
          );
        }

        console.log(
          `\nPlatform fee to deploy: 120 FET (read from contract at deploy time)`,
        );
        console.log(`Trading fee: 2% -> 100% to protocol treasury`);
      },
    );
}
