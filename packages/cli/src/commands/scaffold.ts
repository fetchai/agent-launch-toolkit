/**
 * CLI-002: scaffold command
 *
 * agentlaunch scaffold <name> [--type faucet|research|trading|data]
 *
 * Generates an agent project directory with:
 *   agent.py    - Ready-to-edit agent code based on agent-business-template.py
 *   README.md   - Quickstart instructions
 *   .env.example - Required environment variables
 */

import fs from "node:fs";
import path from "node:path";
import { Command } from "commander";

const DEV_API_URL = 'https://launchpad-backend-dev-1056182620041.us-central1.run.app';
const PROD_API_URL = 'https://agent-launch.ai/api';

function resolveScaffoldApiUrl(): string {
  if (process.env.AGENT_LAUNCH_API_URL) return process.env.AGENT_LAUNCH_API_URL.replace(/\/$/, '');
  if (process.env.AGENT_LAUNCH_BASE_URL) return process.env.AGENT_LAUNCH_BASE_URL.replace(/\/$/, '');
  return process.env.AGENT_LAUNCH_ENV === 'production' ? PROD_API_URL : DEV_API_URL;
}

const SCAFFOLD_API_URL = resolveScaffoldApiUrl();

type AgentType = "faucet" | "research" | "trading" | "data";

/** Per-type customisation slots injected into the template. */
const TYPE_META: Record<
  AgentType,
  { domain: string; description: string; model: string }
> = {
  faucet: {
    domain: "faucet",
    description: "Distributes testnet FET and BNB to new developers",
    model: "mistralai/Mistral-7B-Instruct-v0.2",
  },
  research: {
    domain: "research",
    description: "Delivers on-demand research reports and analysis",
    model: "mistralai/Mistral-7B-Instruct-v0.2",
  },
  trading: {
    domain: "trading",
    description: "Monitors token prices and sends trade alerts",
    model: "mistralai/Mistral-7B-Instruct-v0.2",
  },
  data: {
    domain: "data",
    description: "Serves structured data feeds and query results",
    model: "mistralai/Mistral-7B-Instruct-v0.2",
  },
};

/** Generate agent.py content based on type. */
function generateAgentPy(name: string, type: AgentType): string {
  const meta = TYPE_META[type];
  const className = toPascalCase(name);

  return `#!/usr/bin/env python3
"""
${name} — AgentLaunch ${capitalize(type)} Agent
Generated by: agentlaunch scaffold ${name} --type ${type}

Platform constants (source of truth: deployed smart contracts):
  - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
  - Graduation target: 30,000 FET -> auto DEX listing
  - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)
"""

from uagents import Agent, Context, Protocol
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    EndSessionContent,
    TextContent,
    chat_protocol_spec,
)

import hashlib
import json
import os
import time
from collections import defaultdict
from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import uuid4

import requests

# ==============================================================================
# API CONFIG — Override via environment variables, never hardcode
# ==============================================================================

AGENTLAUNCH_API = os.environ.get("AGENTLAUNCH_API", "${SCAFFOLD_API_URL}")

# ==============================================================================
# BUSINESS CONFIG
# ==============================================================================

OWNER_ADDRESS = os.environ.get("AGENT_OWNER_ADDRESS", "")

BUSINESS = {
    "name": "${name}",
    "description": "${meta.description}",
    "version": "1.0.0",
    "domain": "${meta.domain}",
    "free_requests_per_day": 10,
    "premium_token_threshold": 1000,
    "ai_model": "${meta.model}",
    "rate_limit_per_minute": 20,
    "max_input_length": 5000,
}


# ==============================================================================
# LAYER 1: FOUNDATION
# ==============================================================================


class Logger:
    """Structured logging with audit trail."""

    @staticmethod
    def info(ctx: Context, event: str, data: Optional[Dict] = None) -> None:
        ctx.logger.info(f"[{event}] {json.dumps(data or {})}")

    @staticmethod
    def audit(ctx: Context, user: str, action: str) -> None:
        ctx.logger.info(
            f"[AUDIT] user={user[:20]} action={action} "
            f"ts={datetime.utcnow().isoformat()}"
        )

    @staticmethod
    def error(ctx: Context, event: str, error: str) -> None:
        ctx.logger.error(f"[{event}] {error}")


# ==============================================================================
# LAYER 2: SECURITY
# ==============================================================================


class Security:
    """Rate limiting and input validation."""

    def __init__(self) -> None:
        self._requests: Dict[str, List[float]] = defaultdict(list)
        self._check_count: int = 0

    def check(self, ctx: Context, user_id: str, message: str) -> tuple:
        now = time.time()

        self._requests[user_id] = [
            t for t in self._requests[user_id] if now - t < 60
        ]
        if len(self._requests[user_id]) >= BUSINESS["rate_limit_per_minute"]:
            return None, "Rate limit exceeded. Please wait a moment."
        self._requests[user_id].append(now)

        self._check_count += 1
        if self._check_count % 100 == 0:
            stale = [
                k
                for k, v in self._requests.items()
                if not v or (now - max(v)) > 300
            ]
            for k in stale:
                del self._requests[k]

        if not message or not message.strip():
            return None, "Empty message."
        if len(message) > BUSINESS["max_input_length"]:
            return None, f"Message too long (max {BUSINESS['max_input_length']} chars)."

        return message.strip(), None


# ==============================================================================
# LAYER 3: STABILITY
# ==============================================================================


class Health:
    """Track uptime and error rate."""

    def __init__(self) -> None:
        self._start: datetime = datetime.utcnow()
        self._requests: int = 0
        self._errors: int = 0

    def record(self, success: bool) -> None:
        self._requests += 1
        if not success:
            self._errors += 1

    def status(self) -> Dict[str, Any]:
        uptime = (datetime.utcnow() - self._start).total_seconds()
        error_rate = (self._errors / self._requests * 100) if self._requests else 0
        return {
            "status": "healthy" if error_rate < 10 else "degraded",
            "uptime_seconds": int(uptime),
            "requests": self._requests,
            "error_rate": f"{error_rate:.1f}%",
        }


# ==============================================================================
# LAYER 4: SPEED
# ==============================================================================


class Cache:
    """In-memory TTL cache with SHA256 keys."""

    def __init__(self, max_size: int = 1000) -> None:
        self._data: Dict[str, tuple] = {}
        self._max_size: int = max_size

    def get(self, key: str) -> Any:
        if key in self._data:
            value, expires = self._data[key]
            if expires > time.time():
                return value
            del self._data[key]
        return None

    def set(self, key: str, value: Any, ttl: int = 300) -> None:
        if len(self._data) >= self._max_size:
            now = time.time()
            expired = [k for k, (_, exp) in self._data.items() if exp <= now]
            for k in expired:
                del self._data[k]
            if len(self._data) >= self._max_size:
                to_drop = sorted(self._data.items(), key=lambda x: x[1][1])[
                    : self._max_size // 10
                ]
                for k, _ in to_drop:
                    del self._data[k]
        self._data[key] = (value, time.time() + ttl)


# ==============================================================================
# LAYER 5: REVENUE
# ==============================================================================


class Revenue:
    """Token-gated access and daily usage quotas."""

    def __init__(self, cache: Cache) -> None:
        self._cache = cache
        self._usage: Dict[str, List[str]] = defaultdict(list)

    def get_tier(self, user_address: str) -> str:
        cached = self._cache.get(f"tier:{user_address}")
        if cached is not None:
            return cached
        try:
            r = requests.get(
                f"{AGENTLAUNCH_API}/agents/token/{user_address}", timeout=5
            )
            if r.status_code == 200:
                data = r.json()
                balance = data.get("balance", 0)
                tier = (
                    "premium"
                    if balance >= BUSINESS["premium_token_threshold"]
                    else "free"
                )
                self._cache.set(f"tier:{user_address}", tier, ttl=300)
                return tier
        except Exception:
            pass
        return "free"

    def check_quota(self, user_id: str, tier: str) -> tuple:
        today = datetime.utcnow().date().isoformat()
        self._usage[user_id] = [
            t for t in self._usage[user_id] if t.startswith(today)
        ]
        today_usage = len(self._usage[user_id])
        limit = 1000 if tier == "premium" else BUSINESS["free_requests_per_day"]
        if today_usage >= limit:
            if tier == "free":
                return False, (
                    f"Free limit reached ({limit}/day). "
                    f"Hold {BUSINESS['premium_token_threshold']} tokens for premium!"
                )
            return False, f"Daily limit reached ({limit}/day)."
        self._usage[user_id].append(datetime.utcnow().isoformat())
        return True, None


# ==============================================================================
# AGENTLAUNCH INTEGRATION
# ==============================================================================


class AgentLaunch:
    """Create and manage tokens on AgentLaunch."""

    @staticmethod
    def tokenize() -> Dict:
        agent_address = os.environ.get("AGENT_ADDRESS")
        if not agent_address:
            return {"error": "AGENT_ADDRESS env var not set."}
        try:
            r = requests.post(
                f"{AGENTLAUNCH_API}/agents/tokenize",
                headers={
                    "X-API-Key": os.environ.get("AGENTLAUNCH_API_KEY", ""),
                    "Content-Type": "application/json",
                },
                json={
                    "agentAddress": agent_address,
                    "name": BUSINESS["name"],
                    "description": BUSINESS["description"],
                },
                timeout=30,
            )
            return r.json() if r.status_code in [200, 201] else {"error": r.text}
        except Exception as e:
            return {"error": str(e)}


# ==============================================================================
# YOUR BUSINESS LOGIC — Customize this section
# ==============================================================================


class ${className}Business:
    """
    CUSTOMIZE THIS for your ${type} agent.

    Pattern from FET Gifter:  Agent + Wallet + Chat + Value Exchange = Economy
    """

    def __init__(self) -> None:
        pass

    async def handle(self, ctx: Context, user_id: str, message: str, tier: str) -> str:
        # Sanitize to prevent prompt injection
        safe = message.replace("\\n", " ").replace("\\\\n", " ")[:500]

        # TODO: Add your business logic here
        return (
            f"Hello from {BUSINESS['name']}! You said: {safe}\\n\\n"
            f"Tier: {tier}. This is a scaffold — add your logic in ${className}Business.handle()."
        )


# ==============================================================================
# REPLY HELPER
# ==============================================================================


async def reply(ctx: Context, sender: str, text: str, end: bool = False) -> None:
    content = [TextContent(type="text", text=text)]
    if end:
        content.append(EndSessionContent(type="end-session"))
    try:
        await ctx.send(
            sender,
            ChatMessage(timestamp=datetime.utcnow(), msg_id=uuid4(), content=content),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send reply to {sender[:20]}: {e}")


# ==============================================================================
# MAIN AGENT
# ==============================================================================

cache = Cache(max_size=1000)
security = Security()
health = Health()
revenue = Revenue(cache)
business = ${className}Business()

agent = Agent()
chat_proto = Protocol(spec=chat_protocol_spec)


@chat_proto.on_message(ChatMessage)
async def handle_chat(ctx: Context, sender: str, msg: ChatMessage) -> None:
    try:
        await ctx.send(
            sender,
            ChatAcknowledgement(
                timestamp=datetime.utcnow(), acknowledged_msg_id=msg.msg_id
            ),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send ack to {sender[:20]}: {e}")

    text = " ".join(
        item.text for item in msg.content if isinstance(item, TextContent)
    ).strip()
    text = text[: BUSINESS["max_input_length"]]

    clean, error = security.check(ctx, sender, text)
    if error:
        health.record(False)
        await reply(ctx, sender, error, end=True)
        return

    Logger.audit(ctx, sender, "request")

    lower = clean.lower()

    if lower in ("help", "?"):
        tier = revenue.get_tier(sender)
        await reply(
            ctx,
            sender,
            f"**{BUSINESS['name']}** v{BUSINESS['version']}\\n\\n"
            f"{BUSINESS['description']}\\n\\n"
            f"Your tier: {tier.upper()}\\n\\n"
            f"Commands: help, status, tokenize",
        )
        return

    if lower == "status":
        s = health.status()
        await reply(
            ctx,
            sender,
            f"Status: {s['status']} | Uptime: {s['uptime_seconds']}s | "
            f"Requests: {s['requests']} | Error rate: {s['error_rate']}",
        )
        return

    if "tokenize" in lower:
        if OWNER_ADDRESS and sender != OWNER_ADDRESS:
            await reply(ctx, sender, "Only the agent owner can trigger tokenization.", end=True)
            return
        result = AgentLaunch.tokenize()
        link = result.get("data", {}).get("handoff_link") or result.get("handoff_link")
        await reply(
            ctx,
            sender,
            f"Token created! Deploy here: {link}" if link else f"Result: {json.dumps(result)}",
            end=True,
        )
        return

    tier = revenue.get_tier(sender)
    allowed, quota_error = revenue.check_quota(sender, tier)
    if not allowed:
        health.record(False)
        await reply(ctx, sender, quota_error, end=True)
        return

    try:
        response = await business.handle(ctx, sender, clean, tier)
        health.record(True)
    except Exception as e:
        health.record(False)
        Logger.error(ctx, "business_handle", str(e))
        response = "Something went wrong. Please try again."

    await reply(ctx, sender, response, end=True)


@chat_proto.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement) -> None:
    ctx.logger.debug(f"Ack from {sender[:20]} for msg {msg.acknowledged_msg_id}")


@agent.on_interval(period=3600)
async def periodic_health(ctx: Context) -> None:
    ctx.logger.info(f"[HEALTH] {json.dumps(health.status())}")


agent.include(chat_proto, publish_manifest=True)

if __name__ == "__main__":
    agent.run()
`;
}

/** Generate README.md for the scaffolded project. */
function generateReadme(name: string, type: AgentType): string {
  return `# ${name}

AgentLaunch ${capitalize(type)} Agent — generated by \`agentlaunch scaffold\`.

## Quickstart

### 1. Install dependencies

\`\`\`bash
pip install uagents uagents-core requests
\`\`\`

### 2. Configure environment

\`\`\`bash
cp .env.example .env
# Edit .env and fill in the required values
\`\`\`

### 3. Customize your agent

Open \`agent.py\` and edit the \`${toPascalCase(name)}Business.handle()\` method.
This is where your agent's value exchange lives.

### 4. Run locally

\`\`\`bash
source .env && python agent.py
\`\`\`

### 5. Deploy to Agentverse

\`\`\`bash
agentlaunch deploy
\`\`\`

This uploads \`agent.py\` to Agentverse, sets secrets, and starts the agent.

### 6. Tokenize your agent

\`\`\`bash
agentlaunch tokenize \\
  --agent <address> \\
  --name "${name}" \\
  --symbol "${name.slice(0, 4).toUpperCase()}"
\`\`\`

You will receive a handoff link. Share it with a human to complete on-chain deployment.

## Platform Constants

- Deploy fee: **120 FET** (read dynamically from contract)
- Graduation target: **30,000 FET** — auto DEX listing
- Trading fee: **2%** — 100% to protocol treasury (no creator fee)

## Key Commands

| Command | Description |
|---------|-------------|
| \`agentlaunch config show\` | Show current config |
| \`agentlaunch deploy\` | Deploy agent.py to Agentverse |
| \`agentlaunch tokenize\` | Create a token record + handoff link |

## Resources

- [AgentLaunch Platform](https://agent-launch.ai)
- [Agentverse](https://agentverse.ai)
- [skill.md](https://agent-launch.ai/skill.md)
- [API docs](https://agent-launch.ai/docs/openapi)
`;
}

/** Generate .env.example */
function generateEnvExample(name: string): string {
  return `# ${name} — Environment Variables
# Copy to .env and fill in real values. Never commit .env.

# Your Agentverse API key (https://agentverse.ai/profile/api-keys)
AGENTVERSE_API_KEY=

# Your AgentLaunch API key (same as Agentverse key in most cases)
AGENTLAUNCH_API_KEY=

# The address of this agent on Agentverse (set after first deploy)
AGENT_ADDRESS=

# The wallet address that owns this agent (for owner-gated commands)
AGENT_OWNER_ADDRESS=

# Optional: override the API base URL (default: dev Cloud Run URL; set AGENT_LAUNCH_ENV=production for prod)
# AGENTLAUNCH_API=${SCAFFOLD_API_URL}

# Optional: Hugging Face API key for AI features
# HUGGINGFACE_API_KEY=
`;
}

export function registerScaffoldCommand(program: Command): void {
  program
    .command("scaffold <name>")
    .description(
      "Generate an agent project from template in a new directory <name>",
    )
    .option(
      "--type <type>",
      "Agent type: faucet, research, trading, data (default: research)",
      "research",
    )
    .option("--json", "Output only JSON (machine-readable)")
    .action((name: string, options: { type: string; json?: boolean }) => {
      const isJson = options.json === true;
      const type = options.type as AgentType;
      const validTypes: AgentType[] = ["faucet", "research", "trading", "data"];

      if (!validTypes.includes(type)) {
        if (isJson) {
          console.log(
            JSON.stringify({ error: `--type must be one of: ${validTypes.join(", ")}` }),
          );
        } else {
          console.error(
            `Error: --type must be one of: ${validTypes.join(", ")}`,
          );
        }
        process.exit(1);
      }

      // Sanitize directory name
      const dirName = name.replace(/[^a-zA-Z0-9_-]/g, "-").toLowerCase();
      const targetDir = path.resolve(process.cwd(), dirName);

      if (fs.existsSync(targetDir)) {
        if (isJson) {
          console.log(JSON.stringify({ error: `Directory "${dirName}" already exists.` }));
        } else {
          console.error(`Error: Directory "${dirName}" already exists.`);
        }
        process.exit(1);
      }

      if (!isJson) {
        console.log(`Scaffolding ${capitalize(type)} agent: ${name}`);
        console.log(`Directory: ${targetDir}`);
      }

      fs.mkdirSync(targetDir, { recursive: true });

      const files: Record<string, string> = {
        "agent.py": generateAgentPy(name, type),
        "README.md": generateReadme(name, type),
        ".env.example": generateEnvExample(name),
      };

      for (const [filename, content] of Object.entries(files)) {
        const filePath = path.join(targetDir, filename);
        fs.writeFileSync(filePath, content, "utf8");
        if (!isJson) console.log(`  Created: ${filename}`);
      }

      if (isJson) {
        console.log(
          JSON.stringify({
            name,
            type,
            directory: targetDir,
            files: Object.keys(files),
          }),
        );
      } else {
        console.log(`\nDone! Next steps:\n`);
        console.log(`  cd ${dirName}`);
        console.log(`  cp .env.example .env`);
        console.log(`  # Edit .env and agent.py`);
        console.log(`  agentlaunch deploy`);
      }
    });
}

// --- helpers ---

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function toPascalCase(s: string): string {
  return s
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, c: string) => c.toUpperCase())
    .replace(/^(.)/, (c: string) => c.toUpperCase());
}
