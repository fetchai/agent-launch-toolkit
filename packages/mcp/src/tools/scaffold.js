import * as fs from "fs";
import * as path from "path";
const AGENT_TYPE_CONFIGS = {
    faucet: {
        domain: "faucet",
        description: "Distribute FET tokens to agents on request",
        freeRequestsPerDay: 5,
        rateLimitPerMinute: 10,
        businessLogicComment: "Check balance, validate request, send FET via wallet integration",
    },
    research: {
        domain: "research",
        description: "Answer questions and retrieve data from external sources",
        freeRequestsPerDay: 10,
        rateLimitPerMinute: 20,
        businessLogicComment: "Query external APIs, summarise findings with LLM, return structured data",
    },
    trading: {
        domain: "trading",
        description: "Execute autonomous trading strategies and report positions",
        freeRequestsPerDay: 20,
        rateLimitPerMinute: 30,
        businessLogicComment: "Analyse market data, evaluate strategy signals, report recommended actions",
    },
    data: {
        domain: "data",
        description: "Collect, transform, and serve structured data feeds",
        freeRequestsPerDay: 50,
        rateLimitPerMinute: 60,
        businessLogicComment: "Fetch from data sources, normalise schema, cache results, serve to callers",
    },
};
// ---------------------------------------------------------------------------
// File generators
// ---------------------------------------------------------------------------
function generateAgentPy(name, config) {
    // Sanitise the name for use as a Python identifier
    const safeName = name.replace(/[^a-zA-Z0-9_]/g, "_");
    return `"""
${name} — Agentverse Agent
Generated by agent-launch-mcp scaffold_agent tool.

Type: ${config.domain}
Description: ${config.description}

Platform constants (source of truth: deployed smart contracts):
  - Deploy fee: 120 FET (read dynamically, can change via multi-sig)
  - Graduation target: 30,000 FET -> auto DEX listing
  - Trading fee: 2% -> 100% to protocol treasury (NO creator fee)

Customise the ${safeName}Business.handle() method with your logic.
"""

from uagents import Agent, Context, Protocol
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    EndSessionContent,
    TextContent,
    chat_protocol_spec,
)

import hashlib
import json
import os
import time
from collections import defaultdict
from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import uuid4

import requests


# ==============================================================================
# API CONFIG
# ==============================================================================

AGENTLAUNCH_API = os.environ.get(
    "AGENTLAUNCH_API", "https://agent-launch.ai/api"
)

# ==============================================================================
# BUSINESS CONFIG
# ==============================================================================

OWNER_ADDRESS = os.environ.get("AGENT_OWNER_ADDRESS", "")

BUSINESS = {
    "name": "${name}",
    "description": "${config.description}",
    "version": "1.0.0",
    "domain": "${config.domain}",
    "free_requests_per_day": ${config.freeRequestsPerDay},
    "premium_token_threshold": 1000,
    "ai_model": "mistralai/Mistral-7B-Instruct-v0.2",
    "rate_limit_per_minute": ${config.rateLimitPerMinute},
    "max_input_length": 5000,
}


# ==============================================================================
# LAYER 1: FOUNDATION
# ==============================================================================


class Logger:
    @staticmethod
    def info(ctx: Context, event: str, data: Optional[Dict] = None) -> None:
        ctx.logger.info(f"[{event}] {json.dumps(data or {})}")

    @staticmethod
    def audit(ctx: Context, user: str, action: str, data: Optional[Dict] = None) -> None:
        ctx.logger.info(
            f"[AUDIT] user={user[:20]} action={action} "
            f"ts={datetime.utcnow().isoformat()}"
        )

    @staticmethod
    def error(ctx: Context, event: str, error: str) -> None:
        ctx.logger.error(f"[{event}] {error}")


# ==============================================================================
# LAYER 2: SECURITY
# ==============================================================================


class Security:
    def __init__(self) -> None:
        self._requests: Dict[str, List[float]] = defaultdict(list)
        self._check_count: int = 0

    def check(self, ctx: Context, user_id: str, message: str) -> tuple:
        now = time.time()
        self._requests[user_id] = [
            t for t in self._requests[user_id] if now - t < 60
        ]
        if len(self._requests[user_id]) >= BUSINESS["rate_limit_per_minute"]:
            return None, "Rate limit exceeded. Please wait a moment."
        self._requests[user_id].append(now)

        self._check_count += 1
        if self._check_count % 100 == 0:
            stale = [
                k for k, v in self._requests.items()
                if not v or (now - max(v)) > 300
            ]
            for k in stale:
                del self._requests[k]

        if not message or not message.strip():
            return None, "Empty message."
        if len(message) > BUSINESS["max_input_length"]:
            return None, f"Message too long (max {BUSINESS['max_input_length']} chars)."

        return message.strip(), None


# ==============================================================================
# LAYER 3: STABILITY
# ==============================================================================


class Health:
    def __init__(self) -> None:
        self._start: datetime = datetime.utcnow()
        self._requests: int = 0
        self._errors: int = 0

    def record(self, success: bool) -> None:
        self._requests += 1
        if not success:
            self._errors += 1

    def status(self) -> Dict[str, Any]:
        uptime = (datetime.utcnow() - self._start).total_seconds()
        error_rate = (self._errors / self._requests * 100) if self._requests else 0
        return {
            "status": "healthy" if error_rate < 10 else "degraded",
            "uptime_seconds": int(uptime),
            "requests": self._requests,
            "error_rate": f"{error_rate:.1f}%",
        }


# ==============================================================================
# LAYER 4: SPEED
# ==============================================================================


class Cache:
    def __init__(self, max_size: int = 1000) -> None:
        self._data: Dict[str, tuple] = {}
        self._max_size: int = max_size

    def get(self, key: str) -> Any:
        if key in self._data:
            value, expires = self._data[key]
            if expires > time.time():
                return value
            del self._data[key]
        return None

    def set(self, key: str, value: Any, ttl: int = 300) -> None:
        if len(self._data) >= self._max_size:
            now = time.time()
            expired = [k for k, (_, exp) in self._data.items() if exp <= now]
            for k in expired:
                del self._data[k]
            if len(self._data) >= self._max_size:
                to_drop = sorted(
                    self._data.items(), key=lambda x: x[1][1]
                )[: self._max_size // 10]
                for k, _ in to_drop:
                    del self._data[k]
        self._data[key] = (value, time.time() + ttl)


class AI:
    def __init__(self, cache: Cache) -> None:
        self._cache = cache

    def generate(self, prompt: str) -> str:
        key = hashlib.sha256(prompt.encode()).hexdigest()
        cached = self._cache.get(key)
        if cached is not None:
            return cached
        try:
            r = requests.post(
                f"https://api-inference.huggingface.co/models/{BUSINESS['ai_model']}",
                headers={"Authorization": f"Bearer {os.environ.get('HUGGINGFACE_API_KEY', '')}"},
                json={"inputs": prompt, "parameters": {"max_new_tokens": 500, "temperature": 0.7}},
                timeout=30,
            )
            if r.status_code == 200:
                result = r.json()
                if isinstance(result, list) and result:
                    text = result[0].get("generated_text", "")
                    self._cache.set(key, text)
                    return text
        except Exception:
            return "I'm having trouble processing that right now. Please try again."
        return ""


# ==============================================================================
# LAYER 5: REVENUE
# ==============================================================================


class Revenue:
    def __init__(self, cache: Cache) -> None:
        self._cache = cache
        self._usage: Dict[str, List[str]] = defaultdict(list)

    def get_tier(self, user_address: str) -> str:
        cached = self._cache.get(f"tier:{user_address}")
        if cached is not None:
            return cached
        try:
            r = requests.get(
                f"{AGENTLAUNCH_API}/agents/token/{user_address}", timeout=5
            )
            if r.status_code == 200:
                data = r.json()
                balance = data.get("balance", 0)
                tier = "premium" if balance >= BUSINESS["premium_token_threshold"] else "free"
                self._cache.set(f"tier:{user_address}", tier, ttl=300)
                return tier
        except Exception:
            pass
        return "free"

    def check_quota(self, user_id: str, tier: str) -> tuple:
        today = datetime.utcnow().date().isoformat()
        self._usage[user_id] = [
            t for t in self._usage[user_id] if t.startswith(today)
        ]
        today_usage = len(self._usage[user_id])
        limit = 1000 if tier == "premium" else BUSINESS["free_requests_per_day"]
        if today_usage >= limit:
            if tier == "free":
                return False, (
                    f"Free limit reached ({limit}/day). "
                    f"Hold {BUSINESS['premium_token_threshold']} tokens for premium access!"
                )
            return False, f"Daily limit reached ({limit}/day)."
        self._usage[user_id].append(datetime.utcnow().isoformat())
        return True, None


# ==============================================================================
# AGENTLAUNCH INTEGRATION
# ==============================================================================


class AgentLaunch:
    @staticmethod
    def tokenize() -> Dict:
        agent_address = os.environ.get("AGENT_ADDRESS")
        if not agent_address:
            return {"error": "AGENT_ADDRESS environment variable is not set."}
        try:
            r = requests.post(
                f"{AGENTLAUNCH_API}/agents/tokenize",
                headers={
                    "X-API-Key": os.environ.get("AGENTLAUNCH_API_KEY", ""),
                    "Content-Type": "application/json",
                },
                json={
                    "agentAddress": agent_address,
                    "name": BUSINESS["name"],
                    "description": BUSINESS["description"],
                },
                timeout=30,
            )
            return r.json() if r.status_code in [200, 201] else {"error": r.text}
        except Exception as e:
            return {"error": str(e)}


# ==============================================================================
# YOUR BUSINESS LOGIC — customise this
# ==============================================================================


class ${safeName}Business:
    """
    ${config.businessLogicComment}
    """

    def __init__(self, ai: AI) -> None:
        self.ai = ai

    async def handle(
        self, ctx: Context, user_id: str, message: str, tier: str
    ) -> str:
        # Sanitise for prompt injection safety
        safe_message = message.replace("\\n", " ").replace("\\\\n", " ")[:500]

        prompt = (
            f"You are {BUSINESS['name']}, an AI assistant for {BUSINESS['domain']}.\\n"
            f"User tier: {tier}\\n"
            f"User message: {safe_message}\\n"
            f"Assistant:"
        )

        response = self.ai.generate(prompt)

        if tier == "free":
            response += (
                f"\\n\\n-- Hold {BUSINESS['premium_token_threshold']} "
                f"tokens for premium access! --"
            )

        return response


# ==============================================================================
# REPLY HELPER
# ==============================================================================


async def reply(ctx: Context, sender: str, text: str, end: bool = False) -> None:
    content = [TextContent(type="text", text=text)]
    if end:
        content.append(EndSessionContent(type="end-session"))
    try:
        await ctx.send(
            sender,
            ChatMessage(
                timestamp=datetime.utcnow(),
                msg_id=uuid4(),
                content=content,
            ),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send reply to {sender[:20]}: {e}")


# ==============================================================================
# MAIN AGENT
# ==============================================================================

cache = Cache(max_size=1000)
security = Security()
health = Health()
revenue = Revenue(cache)
ai = AI(cache)
business = ${safeName}Business(ai)

agent = Agent()
chat_proto = Protocol(spec=chat_protocol_spec)


@chat_proto.on_message(ChatMessage)
async def handle_chat(ctx: Context, sender: str, msg: ChatMessage) -> None:
    try:
        await ctx.send(
            sender,
            ChatAcknowledgement(
                timestamp=datetime.utcnow(),
                acknowledged_msg_id=msg.msg_id,
            ),
        )
    except Exception as e:
        ctx.logger.error(f"Failed to send ack to {sender[:20]}: {e}")

    text = " ".join(
        item.text for item in msg.content if isinstance(item, TextContent)
    ).strip()
    text = text[:BUSINESS["max_input_length"]]

    clean, error = security.check(ctx, sender, text)
    if error:
        health.record(False)
        await reply(ctx, sender, error, end=True)
        return

    Logger.audit(ctx, sender, "request")
    lower = clean.lower()

    if lower in ("help", "?"):
        tier = revenue.get_tier(sender)
        await reply(
            ctx,
            sender,
            f"**{BUSINESS['name']}** v{BUSINESS['version']}\\n\\n"
            f"{BUSINESS['description']}\\n\\n"
            f"Your tier: {tier.upper()}\\n\\nCommands: help, status, tokenize",
        )
        return

    if lower == "status":
        s = health.status()
        await reply(
            ctx,
            sender,
            f"**Status:** {s['status']}\\nUptime: {s['uptime_seconds']}s | "
            f"Requests: {s['requests']} | Error rate: {s['error_rate']}",
        )
        return

    if "tokenize" in lower:
        if OWNER_ADDRESS and sender != OWNER_ADDRESS:
            await reply(ctx, sender, "Only the agent owner can trigger tokenization.", end=True)
            return
        result = AgentLaunch.tokenize()
        link = result.get("data", {}).get("handoff_link") or result.get("handoff_link")
        if link:
            await reply(ctx, sender, f"Token created! Deploy here: {link}", end=True)
        else:
            await reply(ctx, sender, f"Tokenization result: {json.dumps(result)}", end=True)
        return

    tier = revenue.get_tier(sender)
    allowed, quota_error = revenue.check_quota(sender, tier)
    if not allowed:
        health.record(False)
        await reply(ctx, sender, quota_error, end=True)
        return

    try:
        response = await business.handle(ctx, sender, clean, tier)
        health.record(True)
    except Exception as e:
        health.record(False)
        Logger.error(ctx, "business_handle", str(e))
        response = "Something went wrong. Please try again."

    await reply(ctx, sender, response, end=True)


@chat_proto.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement) -> None:
    ctx.logger.debug(f"Ack from {sender[:20]} for msg {msg.acknowledged_msg_id}")


@agent.on_interval(period=3600)
async def periodic_cleanup(ctx: Context) -> None:
    ctx.logger.info(f"[HEALTH] {json.dumps(health.status())}")


agent.include(chat_proto, publish_manifest=True)

if __name__ == "__main__":
    agent.run()
`;
}
function generateReadme(name, type, config) {
    return `# ${name}

> ${config.description}

Generated by [agent-launch-mcp](https://www.npmjs.com/package/agent-launch-mcp) \`scaffold_agent\` tool.

## Agent Type

**${type}** — ${config.description}

## Quick Start

### 1. Install dependencies

\`\`\`bash
pip install uagents uagents-core requests
\`\`\`

### 2. Configure environment

Copy \`.env.example\` to \`.env\` and fill in your values:

\`\`\`bash
cp .env.example .env
\`\`\`

### 3. Run locally

\`\`\`bash
python agent.py
\`\`\`

### 4. Deploy to Agentverse

\`\`\`bash
# Install deploy helper
pip install requests

# Deploy (replace with your API key)
python -c "
import json, requests, os
api = 'https://agentverse.ai/v1'
key = os.environ['AGENTVERSE_API_KEY']
headers = {'Authorization': f'bearer {key}', 'Content-Type': 'application/json'}

# Create agent
res = requests.post(f'{api}/hosting/agents', headers=headers, json={'name': '${name}'})
addr = res.json()['address']
print('Agent address:', addr)

# Upload code
with open('agent.py') as f:
    code = f.read()
code_array = [{'language': 'python', 'name': 'agent.py', 'value': code}]
requests.put(f'{api}/hosting/agents/{addr}/code', headers=headers, json={'code': json.dumps(code_array)})

# Start
requests.post(f'{api}/hosting/agents/{addr}/start', headers=headers)
print('Done! Check https://agentverse.ai')
"
\`\`\`

## Customise

Edit the \`${name.replace(/[^a-zA-Z0-9_]/g, "_")}Business.handle()\` method in \`agent.py\` with your logic.

## Rate Limits

| Tier | Requests/day | Requirement |
|------|-------------|-------------|
| Free | ${config.freeRequestsPerDay} | Default |
| Premium | 1000 | Hold 1000 tokens |

## Tokenize Your Agent

Send the \`tokenize\` command to your agent from the owner address, or call the API directly:

\`\`\`bash
curl -X POST https://agent-launch.ai/api/agents/tokenize \\
  -H "X-API-Key: YOUR_KEY" \\
  -H "Content-Type: application/json" \\
  -d '{"agentAddress": "YOUR_AGENT_ADDRESS", "name": "${name}", "description": "${config.description}"}'
\`\`\`

Then open the returned \`handoffLink\` to deploy on-chain with your wallet.

## Platform Notes

- Trading fee: 2% — goes 100% to protocol treasury
- Graduation: 30,000 FET raised → auto-lists on DEX
- Deploy fee: 120 FET (read dynamically from contract)
`;
}
function generateEnvExample(name) {
    return `# ${name} — Environment Variables
# Copy this file to .env and fill in your values

# Required: Agentverse API key (https://agentverse.ai/profile/api-keys)
AGENTVERSE_API_KEY=

# Required: Your agent's Agentverse address (set after first deploy)
AGENT_ADDRESS=

# Optional: Your wallet address — restricts the "tokenize" command to owner only
AGENT_OWNER_ADDRESS=

# Optional: AgentLaunch API base URL (default: https://agent-launch.ai/api)
AGENTLAUNCH_API=https://agent-launch.ai/api

# Optional: HuggingFace API key for LLM responses
HUGGINGFACE_API_KEY=
`;
}
// ---------------------------------------------------------------------------
// Tool implementation
// ---------------------------------------------------------------------------
/**
 * scaffold_agent (MCP-005)
 *
 * Generates an agent project directory from the agent-business-template
 * pattern. Creates agent.py, README.md, and .env.example tailored to the
 * requested agent type.
 */
export async function scaffoldAgent(args) {
    const agentType = args.type ?? "research";
    if (!(agentType in AGENT_TYPE_CONFIGS)) {
        throw new Error(`Unknown agent type "${agentType}". Valid types: faucet, research, trading, data`);
    }
    const config = AGENT_TYPE_CONFIGS[agentType];
    // Resolve output directory
    const outputDir = path.resolve(args.outputDir ?? path.join(process.cwd(), args.name.toLowerCase().replace(/\s+/g, "-")));
    // Create directory (recursive — no error if already exists)
    fs.mkdirSync(outputDir, { recursive: true });
    const filePaths = [];
    // Write agent.py
    const agentPyPath = path.join(outputDir, "agent.py");
    fs.writeFileSync(agentPyPath, generateAgentPy(args.name, config), "utf8");
    filePaths.push(agentPyPath);
    // Write README.md
    const readmePath = path.join(outputDir, "README.md");
    fs.writeFileSync(readmePath, generateReadme(args.name, agentType, config), "utf8");
    filePaths.push(readmePath);
    // Write .env.example
    const envPath = path.join(outputDir, ".env.example");
    fs.writeFileSync(envPath, generateEnvExample(args.name), "utf8");
    filePaths.push(envPath);
    return {
        success: true,
        files: filePaths,
        path: outputDir,
    };
}
// ---------------------------------------------------------------------------
// Handler map
// ---------------------------------------------------------------------------
export const scaffoldHandlers = {
    scaffold_agent: scaffoldAgent,
};
//# sourceMappingURL=scaffold.js.map